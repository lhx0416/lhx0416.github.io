<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习记录">
<meta property="og:type" content="website">
<meta property="og:title" content="Ai吃橘子">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Ai吃橘子">
<meta property="og:description" content="学习记录">
<meta property="og:locale" content="en_US">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Ai吃橘子</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ai吃橘子</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">雄关漫道真如铁，而今迈步从头越</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">学习记录</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai吃橘子">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ai吃橘子">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/" class="post-title-link" itemprop="url">计算机网络八股文</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-04-11 14:51:40 / Modified: 17:32:53" itemprop="dateCreated datePublished" datetime="2023-04-11T14:51:40+08:00">2023-04-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="七层结构"><a href="#七层结构" class="headerlink" title="七层结构"></a>七层结构</h2><p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_46.png" alt="七层结构"></p>
<h2 id="四层结构"><a href="#四层结构" class="headerlink" title="四层结构"></a>四层结构</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png" alt="img"></p>
<p>再给大家贴一下每一层的封装格式：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img"></p>
<p>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>最上层的，也是我们能直接接触到的就是<strong>应用层</strong>（<em>Application Layer</em>），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。所以，<strong>应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。</strong></p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>应用层的数据包会传给传输层，<strong>传输层</strong>（<em>Transport Layer</em>）是为应用层提供网络支持的。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png" alt="img"></p>
<p>在传输层会有两个传输协议，分别是 TCP 和 UDP。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是<strong>网络层</strong>（<em>Internet Layer</em>）。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png" alt="img"></p>
<p>网络层最常使用的是 IP 协议（<em>Internet Protocol</em>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<strong>再次进行分片</strong>，得到一个即将发送到网络的 IP 报文。</p>
<h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>生成了 IP 头部之后，接下来要交给<strong>网络接口层</strong>（<em>Link Layer</em>）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png" alt="img"></p>
<p>网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</p>
<h2 id="输入网址到页面显示整个过程"><a href="#输入网址到页面显示整个过程" class="headerlink" title="输入网址到页面显示整个过程"></a>输入网址到页面显示整个过程</h2><p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_48.png" alt="网址解析"></p>
<ul>
<li><p>首先查看浏览器缓存，如果缓存中有该URL对应的资源，且没有过期，直接显示页面。</p>
</li>
<li><p>解析URL，生成发送给服务器的HTTP请求信息。确定Web服务器和文件名</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_49.png" alt="URL组成"></p>
<blockquote>
<p>生产 HTTP 请求信息</p>
</blockquote>
<p>对 <code>URL</code> 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。</p>
</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_50.png" alt="HTTP消息格式"></p>
<blockquote>
<p>得到请求信息后，要发给谁呢？ 这个时候就需要用DNS来解析域名得到对应的IP地址了。</p>
<blockquote>
<p>域名的层级关系</p>
<p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p>
<p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p>
<p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。</p>
<p>也就是，<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code>。</p>
<p>所以域名的层级关系类似一个树状结构：</p>
<ul>
<li>根 DNS 服务器（.）</li>
<li>顶级域 DNS 服务器（.com）</li>
<li>权威 DNS 服务器（server.com）</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg" alt="DNS 树状结构"></p>
<p>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。</p>
<p>这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。</p>
<p>因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。</p>
</blockquote>
</blockquote>
<ul>
<li><p>DNS查询，查询服务器域名对应的IP地址。</p>
</li>
<li><p>DNS查询步骤</p>
<ul>
<li>首先查看浏览器缓存是否有相应数据，如果有直接返回IP地址</li>
<li>问根域名服务器，根域名服务器会告诉本地DNS应该去哪个顶级域名服务器查询</li>
<li>顶级域名服务器，他会告诉本地域名服务器应该去哪个权威域名服务器查询</li>
<li>权威域名服务器解析域名对应的IP</li>
</ul>
<blockquote>
<p>找到IP之后剩下的流程就是</p>
</blockquote>
</li>
<li><p>建立于目标主机的TCP连接（三次握手）</p>
</li>
<li><p>发送HTTP请求（将报文在TCP&#x2F;IP架构中向下传递并层层封装）</p>
</li>
<li><p>服务器处理HTTP请求并返回响应HTTP报文（将报文在TCP&#x2F;IP架构中向上传递并层层解封装）</p>
</li>
<li><p>浏览器解析渲染页面</p>
</li>
<li><p>当不需要连接后断开TCP连接（四次挥手）</p>
</li>
</ul>
<h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><blockquote>
<p>TCP 的全称叫传输控制协议（<em>Transmission Control Protocol</em>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。</p>
<p>UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。</p>
</blockquote>
<ul>
<li><p>连接不同：tcp是面向连接的，传输数据前要先建立连接；udp是不需要连接的即刻传输数据。</p>
</li>
<li><p>服务对象：tcp只支持一对一的数据传输；udp支持一对一、一对多、多对多的通信。</p>
</li>
<li><p>可靠性方面：tcp是提供可靠交付的，数据可以无差错、不丢失、不重复的按需到达；udp是尽最大努力交付，不保证可靠交付。</p>
</li>
<li><p>拥塞控制和流量控制方面：tcp有拥塞控制和流量控制，能保证数据的安全性；但udp没有，即使网络非常拥堵了也不会影响udp的发送速率。</p>
</li>
<li><p>首部开销方面：tcp首部长度较长，开销会稍大一些，在没有使用选项字段时是20字节，使用了会更多；udp的是首部只有8字节，是固定不变的。开销较小。</p>
</li>
<li><p>传输方式方面：tcp是流式传输，没有边界，但保证顺序可靠；udp是一个包一个包的发送，有边界，但可能会丢包和乱序。</p>
</li>
<li><p>分片方式方面：tcp的数据大小如果大于MSS，会在传输层进行分片，目的主机收到后，在传输层组装tcp数据包，如果中途丢失了一个分片，子需要传输丢失的分片；udp的数据大小如果大于MTU会在网络层分片，目的主机收到后在网络层组装完数据向上层传输，如果丢失分片，则需要重传所有数据包，所以一般udp传输的报文数据应该小于MTU。</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_52.png" alt="UDP头部格式"></p>
</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_51.png" alt="TCP头部格式"></p>
<h2 id="TCP三次握手，四次挥手示意图"><a href="#TCP三次握手，四次挥手示意图" class="headerlink" title="TCP三次握手，四次挥手示意图"></a>TCP三次握手，四次挥手示意图</h2><p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_53.png" alt="三次握手"></p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_54.png" alt="4次挥手"></p>
<h2 id="为什么需要三次握手，两次不行吗？"><a href="#为什么需要三次握手，两次不行吗？" class="headerlink" title="为什么需要三次握手，两次不行吗？"></a>为什么需要三次握手，两次不行吗？</h2><p>弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</li>
<li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ul>
<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>
<p>此外</p>
<ul>
<li><p>三次握手才可以阻止重复历史连接的初始化（主要原因）</p>
</li>
<li><p>三次握手才可以同步双方的初始序列号</p>
</li>
<li><p>三次握手才可以避免资源浪费</p>
</li>
</ul>
<p>试想如果是用两次握手，则会出现下面这种情况：</p>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在<strong>某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端</strong>，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><ul>
<li>攻击者短时间内伪造不同的IP地址，向服务器发送SYN报文，让服务器接受以为有正常的连接，会在SYN接收队列中记录并回复应答报文，但没有后续，直到将服务器的SYN接收队列占满，真正正常的用户无法连接服务器</li>
<li>可以增大SYN接受队列的长度、减少SYN+ACK重传次数</li>
</ul>
<h2 id="挥手为什么需要四次？"><a href="#挥手为什么需要四次？" class="headerlink" title="挥手为什么需要四次？"></a>挥手为什么需要四次？</h2><h3 id="第一种回答"><a href="#第一种回答" class="headerlink" title="第一种回答"></a>第一种回答</h3><p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中<strong>ACK报文是用来应答的，SYN报文是用来同步的</strong>。但是关闭连接时，当<strong>服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。</strong></p>
<h3 id="第二种回答"><a href="#第二种回答" class="headerlink" title="第二种回答"></a>第二种回答</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<h2 id="为什么TIME-WAIT等待时间为2MSL"><a href="#为什么TIME-WAIT等待时间为2MSL" class="headerlink" title="为什么TIME_WAIT等待时间为2MSL"></a>为什么TIME_WAIT等待时间为2MSL</h2><ul>
<li>如果第四次挥手ACK报文丢失，服务端没有断开连接，服务端会重发FIN报文，所以客户端在发送完ACK报文后需要等待。2MSL正好是允许报文丢失一次的时间</li>
</ul>
<h2 id="TCP保证可靠传输"><a href="#TCP保证可靠传输" class="headerlink" title="TCP保证可靠传输"></a>TCP保证可靠传输</h2><ul>
<li><p>重传机制：根据序列号和确认应答号，判断是否收到数据包。<strong>重传解决数据包丢失情况</strong></p>
<ul>
<li>超时重传：数据包丢失；确认应答丢失。<strong>超时重传时间应该略大于报文往返时间RTT</strong>。每遇到超时重传，会把下次超时时间翻倍，两次超时后，不再进行重传</li>
<li>快速重传：连续收到3次相同的ACK，说明中间有包丢失，进行重传。解决了超时时间设置问题。但不知道重传哪几个报文</li>
<li>SACK：选择性确认。在TCP头部字段中加入SACK，将已接受到的数据发送给发送方，发送方就知道重传哪些报文</li>
<li>D-SACK：有哪些数据被重复接受了。可以判断到底是，数据包丢失或ACK丢失或网络延迟</li>
</ul>
</li>
<li><p>滑动窗口：窗口大小（字节数）就是指<strong>无需等待确认应答，而可以继续发送数据长度的最大值</strong>。TCP头部的Window字段就是窗口大小，一般由接收方决定。</p>
</li>
<li><p>流量控制：根据接收方的接受能力控制发送数据量。</p>
<ul>
<li>接收端没有及时处理缓冲区的数据，导致接收窗口变小，发送窗口也变小</li>
<li>窗口大小为0后，发送方无法给接受方发送数据。发送方隔一段时间，会向接收方发送窗口探测报文</li>
</ul>
</li>
<li><p>拥塞控制：在网络拥挤的情况下，避免发送的数据填满整个网络。<strong>拥塞窗口，根据网络情况动态改变的窗口大小，发送窗口最终的值为拥塞窗口和流量控制窗口的最小值</strong></p>
<ul>
<li>慢启动：刚开始拥塞窗口大小成指数型增强：1，2，4…..</li>
<li>拥塞避免：当窗口大小超过thresh阈值后，拥塞窗口大小成线性增长，每收到一个ACK增加<strong>1&#x2F;窗口大小</strong>，接收到一整个窗口ACK，增加1</li>
<li>拥塞发生：触发重传机制。<strong>超时重传</strong>后，拥塞窗口值直接变为1，thresh阈值为原来的1&#x2F;2。<strong>快速重传</strong>后，拥塞窗口的值变为原来的1&#x2F;2，阈值不变</li>
<li>快速恢复：在快速重传后使用，拥塞窗口变为thresh+3，重传数据包，如果收到重复的ACK，拥塞窗口值+1。收到新的ACK后，恢复过程结束，窗口大小变为thresh阈值</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_55.png" alt="拥塞控制"></p>
</li>
</ul>
<h2 id="TCP半连接和全连接队列"><a href="#TCP半连接和全连接队列" class="headerlink" title="TCP半连接和全连接队列"></a>TCP半连接和全连接队列</h2><ul>
<li>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></li>
</ul>
<h2 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h2><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p>
<blockquote>
<p>能否详细解释「超文本传输协议」？</p>
</blockquote>
<p>HTTP 的名字「超文本协议传输」，它可以拆成三个部分：</p>
<ul>
<li>超文本</li>
<li>传输</li>
<li>协议</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/3-HTTP%E4%B8%89%E9%83%A8%E5%88%86.png" alt="三个部分"></p>
<h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><ul>
<li>HTTP是明文传输，存在安全风险。HTTPS对传输数据进行加密，更加安全</li>
<li>HTTP连接建立只需要TCP三次握手；而HTTPS还需要进行SSL&#x2F;TLS握手，才可进入加密报文传输。</li>
<li>HTTP端口号为80；HTTPS为443</li>
<li>HTTPS需要向CA申请数字证书，证明服务器的身份是可信的</li>
</ul>
<h2 id="HTTPS-解决了-HTTP-的哪些问题？"><a href="#HTTPS-解决了-HTTP-的哪些问题？" class="headerlink" title="HTTPS 解决了 HTTP 的哪些问题？"></a>HTTPS 解决了 HTTP 的哪些问题？</h2><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"></p>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>
</ul>
<h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><ul>
<li><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少</p>
</li>
<li><pre><code>2xx
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态</span><br><span class="line"></span><br><span class="line">  - 200：一切正常</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  3xx</span><br></pre></td></tr></table></figure>

类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是

重定向

- 301：永久重定向
- 302：临时重定向
- 304：重定向存在缓存文件
</code></pre>
</li>
<li><pre><code>4xx
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  类状态码表示客户端发送的</span><br><span class="line"></span><br><span class="line">  报文有误</span><br><span class="line"></span><br><span class="line">  ，服务器无法处理，也就是错误码的含义</span><br><span class="line"></span><br><span class="line">  - 400：表示客户端请求的报文有错误</span><br><span class="line">  - 403：服务器禁止访问资源</span><br><span class="line">  - 404：请求资源不存在或找不到</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  5xx</span><br></pre></td></tr></table></figure>

 

类状态码表示客户端请求报文正确，但是

服务器处理时内部发生了错误

，属于服务器端的错误码

- 500：服务端有错误
- 501：客户端请求功能还不支持
- 503：服务器很忙，无法响应
</code></pre>
</li>
</ul>
<h2 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h2><ul>
<li>GET是从服务器获得指定资源，POST是请求对指定资源做相应的处理</li>
<li>GET的请求参数一般在URL中，浏览器会对URL长度有限制，POST数据在报文body中</li>
</ul>
<p>如果从 RFC 规范定义的语义来看：</p>
<ul>
<li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</li>
<li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li>
</ul>
<h2 id="Cookie和Session区别"><a href="#Cookie和Session区别" class="headerlink" title="Cookie和Session区别"></a>Cookie和Session区别</h2><ul>
<li>Cookie一般用来保存用户信息（登录信息，在cookie中放入token）。Session主要在服务端记录用户状态（添加购物车，使用session表明用户身份）</li>
<li>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端</li>
</ul>
<h2 id="HTTPS建立连接过程"><a href="#HTTPS建立连接过程" class="headerlink" title="HTTPS建立连接过程"></a>HTTPS建立连接过程</h2><ul>
<li>ClientHello：由客户端向服务器发起加密通信请求，包含了SSL协议版本、客户端随机数C、支持的密码套件</li>
<li>SeverHello：确认SSL协议版本、服务端随机数S、确认采用的密码套件、CA证书</li>
<li>客户端回应<ul>
<li>首先通过浏览器或操作系统中的CA公钥，验证服务器身份</li>
<li>从数字证书中取出<strong>服务器公钥</strong>，使用它加密报文：随机数pre-master、之前数据的摘要。之后都采用加密传输</li>
</ul>
</li>
<li>服务器回应<ul>
<li>根据pre-master、C、S计算出后续数据传输的密钥</li>
<li>将之前的信息摘要，通过密钥加密后发送给客户端</li>
</ul>
</li>
</ul>
<h2 id="CA证书验证过程"><a href="#CA证书验证过程" class="headerlink" title="CA证书验证过程"></a>CA证书验证过程</h2><p>如下图图所示，为数字证书签发和验证流程：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png" alt="img"></p>
<ul>
<li>CA 签发证书的过程：<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书</li>
</ul>
</li>
<li>客户端校验服务端的数字证书的过程：<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
</li>
</ul>
<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><ul>
<li>简单：基本报文格式header+body，头部信息key-value的形式，容易理解</li>
<li>灵活易扩展：状态码、头字段等都没有固定死，允许开发人员自定义</li>
<li>应用广泛跨平台</li>
<li>长连接：没有主动断开连接，就不断开连接。超过一定的时间，断开连接</li>
<li>无状态</li>
<li>明文传输不安全</li>
<li>管道网络传输：可以同时发起多个请求，解决了请求的队头阻塞问题。但响应需要按顺序接受，响应存在对头阻塞问题</li>
</ul>
<h2 id="HTTP2基于HTTPS"><a href="#HTTP2基于HTTPS" class="headerlink" title="HTTP2基于HTTPS"></a>HTTP2基于HTTPS</h2><ul>
<li>头部压缩：同时发出多个请求，如果头部信息相同，会消除重复部分。<code>HPACK</code>,维护一张头信息表</li>
<li>二进制格式：头信息和数据体都是二进制格式</li>
<li>并发传输：提出了Stream概念，多个Stream复用同一个TCP。不同的请求具有不同的streamID</li>
</ul>
<h2 id="HTTP和RPC"><a href="#HTTP和RPC" class="headerlink" title="HTTP和RPC"></a>HTTP和RPC</h2><ul>
<li>HTTP和RPC都是协议，底层都可以基于TCP或UDP进行实现，只是定义了不同消息格式的应用层协议</li>
<li>RPC要比HTTP1.1效率更高</li>
<li>RPC实现服务调用时，需要双方都使用统一的RPC框架，跨操作系统，同一编程语言。HTTP不需要关注对方使用的编程语言，通用性灵活度更强</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai吃橘子">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ai吃橘子">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-04-11 10:16:32 / Modified: 21:40:50" itemprop="dateCreated datePublished" datetime="2023-04-11T10:16:32+08:00">2023-04-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="十大排序一图总览"><a href="#十大排序一图总览" class="headerlink" title="十大排序一图总览"></a>十大排序一图总览</h2><p><img src="https://oss.interviewguide.cn/img/202205072325169.png" alt="img"></p>
<h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h3><p>冒泡排序 —  插入排序 —归并排序 — 基数排序</p>
<h3 id="非稳定排序"><a href="#非稳定排序" class="headerlink" title="非稳定排序"></a>非稳定排序</h3><p>选择排序 —  希尔排序 — 堆排序 —  快速排序 </p>
<h3 id="各个排序之间的关系"><a href="#各个排序之间的关系" class="headerlink" title="各个排序之间的关系"></a>各个排序之间的关系</h3><p><strong>希尔排序是插入排序的改进版</strong>—–希尔排序是将数组分为gap个数组，然后对每个数组进行插入排序，最后将gap减半，再对每个数组进行插入排序，直到gap为1，最后对整个数组进行插入排序</p>
<p><strong>堆排序是选择排序的改进版</strong>——-堆排序是将数组看成一个完全二叉树，然后将数组调整为一个大顶堆，然后将堆顶的数字和最后一个数字交换，然后将剩下的数字调整为一个大顶堆，再将堆顶的数字和倒数第二个数字交换，依次类推，直到剩下一个数字。堆排序是通过大顶堆来实现选择排序中找到最大值的功能，所以是选择排序的改进版</p>
<p><strong>桶排序的桶内排序是基于别的排序算法，所以不好说是否稳定。</strong></p>
<p><strong>计数排序不是基于比较的排序，排序的速度快于任何比较排序算法。</strong></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="comment">//稳定</span></span><br><span class="line"><span class="comment">//从前往后依次比较，如果发现当前数字比后面的数字大，交换位置</span></span><br><span class="line"><span class="comment">//一次遍历过后 最大的数字出现被交换到数组末尾</span></span><br><span class="line"><span class="comment">//已经排好序的数字不需要参与对比</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">false</span>;<span class="comment">//可以用一个标志位来判断数组现在是否已经有序   </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)<span class="comment">//只需要n-1次遍历就可以完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>()-i<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j],nums[j+<span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="comment">//不稳定</span></span><br><span class="line"><span class="comment">//每次遍历都去找未排序数组中的最小值的下标</span></span><br><span class="line"><span class="comment">//利用swap函数，将找到的当前回合找到的最小值放在已经排好序的数组后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[minIndex]&lt;nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                minInde = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i],nums[minIndex]);<span class="comment">//因为存在这个swap函数，可能破坏稳定性，所以是不稳定的排序。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="comment">//冒泡排序是从头到尾依次比较，如果发现当前数字比后面的数字大，交换位置  比较是在未排序的数组中进行</span></span><br><span class="line"><span class="comment">//选择排序是每次遍历都去找未排序数组中的最小值的下标，然后将最小值放在已经排好序的数组后面  比较是在未排序的数组中进行</span></span><br><span class="line"><span class="comment">//插入排序是从第二个数字开始插入，第一个数字默认已经排好序，然后将当前数字插入到合适的位置，每次都是拿新的元素在已经排好序的数组中进行比较，比较是从后往前进行的</span></span><br><span class="line"><span class="comment">//稳定排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)<span class="comment">//从第二个数字开始插入,第一个数字默认已经排好序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = nums[i];<span class="comment">//记录当前需要插入的数字</span></span><br><span class="line">        <span class="type">int</span> j = i<span class="number">-1</span>;<span class="comment">//记录当前需要插入的数字的前一个数字的下标</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; nums[j]&gt;temp)<span class="comment">//如果当前数字比前一个数字小，就将前一个数字后移</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];<span class="comment">//将前一个数字后移</span></span><br><span class="line">            j--;<span class="comment">//继续比较前一个数字，直到找到合适的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = temp;<span class="comment">//将当前数字插入到合适的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//每次都从数组中选择一个数字作为基准，然后将数组分为两部分，一部分比基准小，一部分比基准大</span></span><br><span class="line"><span class="comment">//然后分别对两部分进行排序，直到数组有序.递归函数可以实现快速排序</span></span><br><span class="line"><span class="comment">//快速排序是不稳定的排序算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;<span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="type">int</span> i = left;<span class="comment">//i指向数组的第一个数字</span></span><br><span class="line">    <span class="type">int</span> j = right;<span class="comment">//j指向数组的最后一个数字</span></span><br><span class="line">    <span class="type">int</span> temp = nums[left];<span class="comment">//记录基准数字</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)<span class="comment">//在这个循环里，先从后往前找到第一个比基准小的数字，然后用这个数字覆盖i位置的数字，那第一个比基准小的数字就出现了两次，（第一次从后往前查找覆盖后基准数字被覆盖了，所以开头要用temp记录基准数字）</span></span><br><span class="line">              <span class="comment">//接着从前往后找到第一个比基准大的数字，然后用这个数字覆盖j位置的数字，那第一个比基准大的数字就出现了两次，</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j]&gt;=temp) j--;<span class="comment">//从后往前找到第一个比基准小的数字</span></span><br><span class="line">        nums[i] = nums[j];<span class="comment">//将找到的数字放到前面，此时i位置的数字被覆盖</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]&lt;=temp) i++;<span class="comment">//从前往后找到第一个比基准大的数字</span></span><br><span class="line">        nums[j] = nums[i];<span class="comment">//将找到的数字放到后面，此时j位置的数字被覆盖</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[i] = temp;<span class="comment">//将基准数字放到中间（此时i=j，怎么写都对），因为在上面的循环中，基准数字已经消失了，所以这一步要把基准数字加回来</span></span><br><span class="line">    <span class="built_in">quickSort</span>(nums,left,i<span class="number">-1</span>);<span class="comment">//对基准左边的数组进行排序</span></span><br><span class="line">    <span class="built_in">quickSort</span>(nums,i+<span class="number">1</span>,right);<span class="comment">//对基准右边的数组进行排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>改进后的代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = right;</span><br><span class="line">    <span class="type">int</span> temp = nums[left];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[j]&gt;=temp) j--;<span class="comment">//从后向前查找比基准小的数字</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) nums[i++] = nums[j];<span class="comment">//i++的话可以让下一步循环时，i指向的数字不是刚刚被覆盖的数字，这样能提高效率</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; nums[i]&lt;=temp) i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) nums[j--] = nums[i]; <span class="comment">//同理，j--的话可以让下一步循环时，j指向的数字不是刚刚被覆盖的数字，这样能提高效率</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[i] = temp;</span><br><span class="line">    <span class="built_in">quickSort</span>(nums,left,i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="comment">//归并排序是稳定的排序算法</span></span><br><span class="line"><span class="comment">//归并排序是将数组分为两部分，然后分别对两部分进行排序，最后将两部分合并。分治思想</span></span><br><span class="line"><span class="comment">//归并排序迭代实现</span></span><br><span class="line"><span class="comment">//归并排序的时间复杂度是O(nlogn)</span></span><br><span class="line"><span class="comment">//归并排序的空间复杂度是O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> <span class="comment">//分治思想 这一步是分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i*=<span class="number">2</span>)<span class="comment">//i表示每次合并的两个数组的长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=<span class="number">2</span>*i)<span class="comment">//j表示每次合并的两个数组的第一个数字的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = j;<span class="comment">//左边数组的第一个数字的位置</span></span><br><span class="line">            <span class="type">int</span> mid = j+i<span class="number">-1</span>;<span class="comment">//左边数组的最后一个数字的位置</span></span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">min</span>(j+<span class="number">2</span>*i<span class="number">-1</span>,n<span class="number">-1</span>);<span class="comment">//防止数组越界,右边数组的最后一个数字的位置</span></span><br><span class="line">            <span class="built_in">merge</span>(nums,left,mid,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span><span class="comment">//分治思想 这一步是治，合并两个有序数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(right-left+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = left;</span><br><span class="line">    <span class="type">int</span> j = mid+<span class="number">1</span>;<span class="comment">//j表示右边数组的第一个数字的位置</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)<span class="comment">//将两个数组中的数字从小到大放到temp数组中,有点双指针的意思</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;=nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++] = nums[i++];<span class="comment">//如果左边的数组还有剩余，就将剩余的数字放到temp数组中</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right) temp[k++] = nums[j++];<span class="comment">//如果右边的数组还有剩余，就将剩余的数字放到temp数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temp.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[left+i] = temp[i];<span class="comment">//将temp数组中的数字放回到nums数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/64fb6440e8a54f1dae25d49eb31df882.png#pic_center" alt="img"></p>
<p>思考：如果是奇数个数字要怎么排序呢？</p>
<p>答案：一个示例</p>
<p>1、数组{6,3,5,4,1,2,7}</p>
<p>2、 分割成 6 3 5 4 1 2 7 第一次排序结果  [3，6] [4，5   ] [1，2 ]  [7]</p>
<p>3、第二次排序结果 [3,4,5,6] [1,2,7]</p>
<p>4、第三次排序结果[1,2,3,4,5,6,7]</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="comment">//希尔排序是不稳定的排序算法（在不同组进行插入排序的过程中，可能引入元素位置交换，造成不稳定）</span></span><br><span class="line"><span class="comment">//希尔排序是插入排序的改进版，插入排序的时间复杂度是O(n^2)，希尔排序的时间复杂度是O(nlogn)</span></span><br><span class="line"><span class="comment">//希尔排序的空间复杂度是O(1)</span></span><br><span class="line"><span class="comment">//希尔排序是将数组分为gap个数组，然后对每个数组进行插入排序，最后将gap减半，再对每个数组进行插入排序，直到gap为1，最后对整个数组进行插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> gap = n/<span class="number">2</span>;<span class="comment">//gap表示每次比较的两个数字的距离</span></span><br><span class="line">    <span class="keyword">while</span>(gap&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;n;i++)<span class="comment">//从第gap个数字开始，依次和前面的数字进行比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="type">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(j-gap&gt;=<span class="number">0</span> &amp;&amp; nums[j-gap]&gt;temp)<span class="comment">//如果前面的数字比后面的数字大，就交换两个数字。这里就是插入排序，只不过是在gap个数组中进行的</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums[j] = nums[j-gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;<span class="comment">//每次比较的两个数字的距离减半</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分组进行插入排序，似乎可以有效减少移动的次数，所以要比插入排序好一点。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="comment">//堆排序是不稳定的排序算法</span></span><br><span class="line"><span class="comment">//堆排序是选择排序的改进版，选择排序的时间复杂度是O(n^2)，堆排序的时间复杂度是O(nlogn)</span></span><br><span class="line"><span class="comment">//堆排序的空间复杂度是O(1)</span></span><br><span class="line"><span class="comment">//堆排序是将数组看成一个完全二叉树，然后将数组调整为一个大顶堆，然后将堆顶的数字和最后一个数字交换，然后将剩下的数字调整为一个大顶堆，再将堆顶的数字和倒数第二个数字交换，依次类推，直到剩下一个数字</span></span><br><span class="line"><span class="comment">//堆排序是通过大顶堆来实现选择排序中找到最大值的功能，所以是选择排序的改进版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//从第一个非叶子节点开始，依次调整为大顶堆</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">adjustHeap</span>(nums,i,n);<span class="comment">//调整为大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)<span class="comment">//将堆顶的数字和最后一个数字交换，然后将剩下的数字调整为一个大顶堆，再将堆顶的数字和倒数第二个数字交换，依次类推，直到剩下一个数字</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>],nums[i]);<span class="comment">//将堆顶的数字和最后一个数字交换，这样最大的数字就放到了数组的最后面</span></span><br><span class="line">        <span class="built_in">adjustHeap</span>(nums,<span class="number">0</span>,i);<span class="comment">//将剩下的数字调整为一个大顶堆，这样就可以找到剩下数字中的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjustHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> i,<span class="type">int</span> length)</span><span class="comment">//调整为大顶堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = nums[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>*i+<span class="number">1</span>;k&lt;length;k=<span class="number">2</span>*k+<span class="number">1</span>)<span class="comment">//从i节点的左子节点开始，也就是2*i+1处开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; nums[k]&lt;nums[k+<span class="number">1</span>])<span class="comment">//如果左子节点小于右子节点，k指向右子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[k]&gt;temp)<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = nums[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><strong>算法原理：</strong></p>
<p>桶排序的核心思想就是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶排序完之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e66489c50d06811c4dcdc276b902f848.png" alt="img"></p>
<p> <strong>桶排序的时间复杂度为O(n)：</strong></p>
<p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k&#x3D;n&#x2F;m 个元素。<strong>每个桶内部使用归并排序（或者别的排序算法，本段后面的内容都是以桶内排序为归并排序写的）</strong>，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k&#x3D;n&#x2F;m，所以整个桶排序的时间复杂度就是 O(n*log(n&#x2F;m))。当桶的个数m 接近数据个数 n 时，log(n&#x2F;m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p>
<p><strong>桶排序的使用条件和适用场景：</strong></p>
<p>桶排序对要排序的数据的要求是非常苛刻的。使用条件如下：</p>
<p>（1）首先，要排序的数据需要很容易就能划分成m个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内数据都排序完之后，桶与桶之间的数据不需要在进行排序。</p>
<p>2）其次，数据在各个桶之间的分布比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的归并排序算法了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桶排序（这个桶是一个有范围的桶，与计数排序中的桶作用相似，但是又有所不同）</span></span><br><span class="line"><span class="comment">//桶排序是稳定的排序算法</span></span><br><span class="line"><span class="comment">//桶排序的时间复杂度是O(n)，但是桶排序的时间复杂度不是线性的，而是O(n+k)，k表示桶的个数</span></span><br><span class="line"><span class="comment">//桶排序的空间复杂度是O(n+k)，k表示桶的个数</span></span><br><span class="line"><span class="comment">//桶排序是将数组中的数字放到不同的桶中，然后对每个桶中的数字进行排序，最后将每个桶中的数字依次取出，就是有序的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxNum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> minNum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//找到数组中的最大值和最小值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            minNum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> bucketNum = (maxNum-minNum)/n+<span class="number">1</span>;<span class="comment">//桶的个数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(bucketNum);<span class="comment">//创建桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//将数组中的数字放到不同的桶中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = (nums[i]-minNum)/n;<span class="comment">//计算每个数字应该放到哪个桶中</span></span><br><span class="line">        bucket[num].<span class="built_in">push_back</span>(nums[i]);<span class="comment">//将数字放到对应的桶中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bucketNum;i++)<span class="comment">//对每个桶中的数字进行排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i].<span class="built_in">size</span>()&gt;<span class="number">0</span>)<span class="comment">//如果桶中有数字，就对桶中的数字进行排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(bucket[i].<span class="built_in">begin</span>(),bucket[i].<span class="built_in">end</span>());<span class="comment">//对桶中的数字进行排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;bucket[i].<span class="built_in">size</span>();j++)<span class="comment">//将每个桶中的数字依次取出，就是有序的数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums[index++] = bucket[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
<ul>
<li>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。</li>
<li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。</li>
<li>计数排序不是比较排序，排序的速度快于任何比较排序算法。</li>
</ul>
<p><strong>算法思想</strong>：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>
<li>向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1；</li>
</ol>
<p><img src="https://oss.interviewguide.cn/img/202205072324770.gif" alt="计数排序"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"><span class="comment">//计数排序是稳定的排序算法</span></span><br><span class="line"><span class="comment">//计数排序的时间复杂度是O(n+k)，k表示数组中的最大值</span></span><br><span class="line"><span class="comment">//计数排序的空间复杂度是O(n+k)，k表示数组中的最大值</span></span><br><span class="line"><span class="comment">//计数排序是将数组中的数字放到不同的桶（这个桶是个固定的值，与桶排序相似但又有所不同）中，然后对每个桶中的数字进行排序，最后将每个桶中的数字依次取出，就是有序的数组</span></span><br><span class="line"><span class="comment">//所以计数排序的要求很高，数组中的数字必须是整数，且数组中的数字必须是有范围的，且范围不能太大，否则会造成空间的浪费</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxNum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> minNum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//找到数组中的最大值和最小值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            minNum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(maxNum-minNum+<span class="number">1</span>)</span></span>;<span class="comment">//创建桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//将数组中的数字放到不同的桶中</span></span><br><span class="line">    &#123;</span><br><span class="line">        count[nums[i]-minNum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count.<span class="built_in">size</span>();i++)<span class="comment">//将每个桶中的数字依次取出，就是有序的数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(count[i]--)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[index++] = i+minNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="comment">//基数排序是稳定的排序算法</span></span><br><span class="line"><span class="comment">//基数排序的时间复杂度是O(d(n+r))，d表示最大的数字有多少位，n表示数组的长度，r表示基数</span></span><br><span class="line"><span class="comment">//基数排序的空间复杂度是O(n+r)，r表示基数</span></span><br><span class="line"><span class="comment">//基数排序是将数组中的数字按照个位、十位、百位...的顺序进行排序，每次排序都是按照个位、十位、百位...的顺序进行排序</span></span><br><span class="line"><span class="comment">//所以基数排序的要求很高，数组中的数字必须是整数，且数组中的数字必须是有范围的，且范围不能太大，否则会造成空间的浪费</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxNum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//找到数组中的最大值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            maxNum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(maxNum)<span class="comment">//计算最大值有多少位</span></span><br><span class="line">    &#123;</span><br><span class="line">        maxDigit++;</span><br><span class="line">        maxNum /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> dev = <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(<span class="number">10</span>);<span class="comment">//创建桶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxDigit;i++,mod*=<span class="number">10</span>,dev*=<span class="number">10</span>)<span class="comment">//按照个位、十位、百位...的顺序进行排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)<span class="comment">//将数组中的数字放到不同的桶（这个桶和桶排序的桶相似）中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = (nums[j]%mod)/dev;<span class="comment">//计算每个数字应该放到哪个桶中</span></span><br><span class="line">            bucket[num].<span class="built_in">push_back</span>(nums[j]);<span class="comment">//将数字放到对应的桶中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;bucket.<span class="built_in">size</span>();j++)<span class="comment">//将每个桶中的数字依次取出，就是有序的数组</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[j].<span class="built_in">size</span>()&gt;<span class="number">0</span>)<span class="comment">//如果桶中有数字，就对桶中的数字进行排序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;bucket[j].<span class="built_in">size</span>();k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    nums[index++] = bucket[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;bucket.<span class="built_in">size</span>();j++)<span class="comment">//清空桶</span></span><br><span class="line">        &#123;</span><br><span class="line">            bucket[j].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/11/C-%E5%85%AB%E8%82%A1%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai吃橘子">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ai吃橘子">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/11/C-%E5%85%AB%E8%82%A1%E6%96%87/" class="post-title-link" itemprop="url">C++八股文</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-04-11 10:09:39 / Modified: 12:16:07" itemprop="dateCreated datePublished" datetime="2023-04-11T10:09:39+08:00">2023-04-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="C-三大特性"><a href="#C-三大特性" class="headerlink" title="C++三大特性"></a>C++三大特性</h1><h2 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h2><p>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。<br>封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。把数据和处理数据的操作结合形成类，数据和函数都是类的成员。</p>
<h3 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h3><p>封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是通过外部接口以及特定的访问权限来使用类的成员。<br>使得代码模块化，提高程序的可读性。</p>
<h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><p>让某种类型对象获得另一个类型对象的属性和方法。它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。继承的过程，就是从一般到特殊的过程。继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。</p>
<h3 id="意义：-1"><a href="#意义：-1" class="headerlink" title="意义："></a>意义：</h3><p>继承可以扩展已存在的代码模块（类），目的是避免公用代码的重复开发，减少代码和数据冗余。<br>继承是在封装的基础上进行的（个人理解），提高了代码的重用性，使得修改或扩展继承而来的实现都较为容易。将⼈定义为⼀个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉等公共⽅法，在定义⼀个具体的⼈时，就可以继承这个抽象类，既保留了公共属性和⽅法，也可以在此基础上扩展跳舞、唱歌等特有⽅法。</p>
<h3 id="public、protected、private-指定继承方式"><a href="#public、protected、private-指定继承方式" class="headerlink" title="public、protected、private 指定继承方式"></a>public、protected、private 指定继承方式</h3><p>不同的继承方式会影响基类成员在派生类中的访问权限。</p>
<ol>
<li><p>public继承方式<br>基类中所有 public 成员在派生类中为 public 属性；<br>基类中所有 protected 成员在派生类中为 protected 属性；<br>基类中所有 private 成员在派生类中不能使用。</p>
</li>
<li><p>protected继承方式<br>基类中的所有 public 成员在派生类中为 protected 属性；<br>基类中的所有 protected 成员在派生类中为 protected 属性；<br>基类中的所有 private 成员在派生类中不能使用。</p>
</li>
<li><p>private继承方式<br>基类中的所有 public 成员在派生类中均为 private 属性；<br>基类中的所有 protected 成员在派生类中均为 private 属性；<br>基类中的所有 private 成员在派生类中不能使用。</p>
</li>
</ol>
<p>通过上面的分析可以发现：</p>
<ol>
<li>基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为 protected 时，那么基类成员在派生类中的访问权限最高也为 protected，高于 protected 的会降级为 protected，但低于 protected 不会升级。再如，当继承方式为 public 时，那么基类成员在派生类中的访问权限将保持不变。</li>
</ol>
<p>也就是说，继承方式中的 public、protected、private 是用来指明基类成员在派生类中的最高访问权限的。</p>
<ol start="2">
<li><p>不管继承方式如何，基类中的 private 成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。</p>
</li>
<li><p>如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为 public 或 protected；只有那些不希望在派生类中使用的成员才声明为 private。</p>
</li>
<li><p>如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。</p>
</li>
</ol>
<p>注意，我们这里说的是基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。<strong>实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。</strong></p>
<p>下表汇总了不同继承方式对不同属性的成员的影响结果</p>
<p>继承方式&#x2F;基类成员	public成员	protected成员	private成员<br>public继承					public	        protected	         不可见<br>protected继承			 protected	  protected	         不可见<br>private继承				  private	       private	              不可见</p>
<h2 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h2><p>个人理解 ：多态是在继承的基础上进行的<br>同⼀事物表现出不同事物的能⼒，即向不同对象发送同⼀消息，不同的对象在接收时会产⽣ 不同的⾏为（重载实现编译时多态，虚函数实现运⾏时多态）</p>
<p>多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。<strong>简单一句话：允许将子类类型的指针赋值给父类类型的指针</strong></p>
<p>实现多态有二种方式：重写（override），重载（overload）。</p>
<p>重写：是指子类重新定义父类的虚函数的做法。</p>
<p>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。</p>
<h3 id="C-中的重载、重写（覆盖）和隐藏的区别"><a href="#C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="C++中的重载、重写（覆盖）和隐藏的区别"></a>C++中的重载、重写（覆盖）和隐藏的区别</h3><p>（1）重载（overload）</p>
<p>重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）重写（覆盖）（override）</p>
<p>重写指的是在派生类中覆盖基类中的同名函数，<strong>重写就是重写函数体</strong>，<strong>要求基类函数必须是虚函数</strong>且：</p>
<ul>
<li>与基类的虚函数有相同的参数个数</li>
<li>与基类的虚函数有相同的参数类型</li>
<li>与基类的虚函数有相同的返回值类型</li>
</ul>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//重写,一般加override可以确保是重写父类的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载与重写的区别：</p>
<ul>
<li>重写是父类和子类之间的垂直关系；重载是不同函数之间的水平关系</li>
<li>重写要求参数列表相同，返回值类型相同，<strong>重写函数体</strong>；重载则要求函数名相同，<strong>参数类型和数目有所不同</strong>，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。</li>
<li>重写关系中，调用方法根据对象类型决定；重载根据调用时实参表与形参表的对应关系来选择函数体</li>
</ul>
<h3 id="意义：-2"><a href="#意义：-2" class="headerlink" title="意义："></a>意义：</h3><p>接口重用</p>
<h3 id="C-的多态如何实现"><a href="#C-的多态如何实现" class="headerlink" title="C++的多态如何实现"></a>C++的多态如何实现</h3><p>C++的多态性，<strong>一言以蔽之</strong>就是：</p>
<p>在基类的函数前加上<strong>virtual</strong>关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; Base::func()&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot; Son1::func()&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* base = <span class="keyword">new</span> Son1;</span><br><span class="line">	base-&gt;<span class="built_in">fun</span>();</span><br><span class="line">	base = <span class="keyword">new</span> Son2;</span><br><span class="line">	base-&gt;<span class="built_in">fun</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;</span><br><span class="line">	base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// Son1::func()</span></span><br><span class="line"><span class="comment">// Base::func()</span></span><br></pre></td></tr></table></figure>

<p>例子中，Base为基类，其中的函数为虚函数。</p>
<p>子类1继承并重写了基类的函数，子类2继承基类但没有重写基类的函数，从结果分析子类体现了多态性。</p>
<p>为什么会出现多态性，其底层的原理是什么？</p>
<p>这里需要引出虚表和虚基表指针的概念。</p>
<p>虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表</p>
<p>虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的指向虚表的指针</p>
<p><img src="https://oss.interviewguide.cn/img/202205220022619.png" alt="img"></p>
<p><img src="https://oss.interviewguide.cn/img/202205220022551.png" alt="img"></p>
<p><strong>上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型，下面阐述实现多态的过程：</strong></p>
<p><strong>（1）</strong>编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址</p>
<p>**（2）**编译器会在每个对象的前四个字节中保存一个虚表指针，即**vptr**，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数</p>
<p><strong>（3）</strong>所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表</p>
<p><strong>（4）</strong>当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面</p>
<p>这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。</p>
<h3 id="为什么析构函数一般写成虚函数"><a href="#为什么析构函数一般写成虚函数" class="headerlink" title="为什么析构函数一般写成虚函数"></a>为什么析构函数一般写成虚函数</h3><p>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</p>
<p>所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Parent</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Parent construct function&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~<span class="built_in">Parent</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Parent destructor function&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son construct function&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~<span class="built_in">Son</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son destructor function&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Parent* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Parent construct function</span></span><br><span class="line"><span class="comment">//Son construct function</span></span><br><span class="line"><span class="comment">//Parent destructor function</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>将基类的析构函数声明为虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Parent</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Parent construct function&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Parent</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Parent destructor function&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Parent&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son construct function&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	~<span class="built_in">Son</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son destructor function&quot;</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Parent* p = <span class="keyword">new</span> <span class="built_in">Son</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//Parent construct function</span></span><br><span class="line"><span class="comment">//Son construct function</span></span><br><span class="line"><span class="comment">//Son destructor function</span></span><br><span class="line"><span class="comment">//Parent destructor function</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/10/2023-4-10%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai吃橘子">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ai吃橘子">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/10/2023-4-10%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">2023/4/10刷题记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-10 20:56:30" itemprop="dateCreated datePublished" datetime="2023-04-10T20:56:30+08:00">2023-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-04-11 13:12:27" itemprop="dateModified" datetime="2023-04-11T13:12:27+08:00">2023-04-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h1><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure>

<p>思路： 首先要去掉多余的空格 ，这个操作可以移植到替换所有的字符。</p>
<p>用快慢指针来做，快指针就一直走，慢指针有条件的移动。然后再将快指针指向的元素复制到慢指针指向的元素里面。</p>
<p>  以这道题目为例，慢指针就是不是空格的元素。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)<span class="comment">//i相当于快指针  一直走，但是要注意空格  如果不是空格就复制字符，如果是空格就继续走  这样就可以把所有的空格都删除</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) </span><br><span class="line">                    s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) <span class="comment">//这个其实很关键，当s[i]==&#x27; &#x27;时，说明遇到了新的空格，慢指针就不能再移动了。</span></span><br><span class="line">                &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后字符串的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="整体代码："><a href="#整体代码：" class="headerlink" title="整体代码："></a>整体代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分为三步</span></span><br><span class="line">        <span class="comment">//1 去掉多余空格  2 反转字符串  3.反转单词</span></span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)<span class="comment">//遇到空格就反转上一个单词</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,start,i<span class="number">-1</span>);</span><br><span class="line">                start = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==s.<span class="built_in">size</span>()<span class="number">-1</span>)<span class="comment">//走到最后了也要反转当前单词</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,start,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。 这样一来，字符串首尾就没有空格了，而且多余的空格也会被去掉</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)<span class="comment">//i相当于快指针  一直走，但是要注意空格  如果不是空格就复制字符，如果是空格就继续走  这样就可以把所有的空格都删除</span></span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) </span><br><span class="line">                    s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) <span class="comment">//这个其实很关键，当s[i]==&#x27; &#x27;时，说明遇到了新的空格，慢指针就不能再移动了。</span></span><br><span class="line">                &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后字符串的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin,j=end;i&lt;j;i++,j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li>
</ul>
<h2 id="整体代码：-1"><a href="#整体代码：-1" class="headerlink" title="整体代码："></a>整体代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//暴力的解法就是 切片，删除，字符串相加</span></span><br><span class="line">        <span class="comment">//用反转来做 可以节省空间</span></span><br><span class="line">        <span class="built_in">reverse</span>(s,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(s,n,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> s; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin,j=end;i&lt;j;i++,j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
