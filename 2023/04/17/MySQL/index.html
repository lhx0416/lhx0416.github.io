<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="MySQL基础说一下MySQL是如何执行一条SQL的？具体步骤有哪些？ Server层按顺序执行sql的步骤为：  客户端请求-&gt; 连接器（验证用户身份，给予权限） -&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt; 分析器（对SQL进行词法分析和语法分析操作） -&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt; 执行器（执行时会先看用户是">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://example.com/2023/04/17/MySQL/index.html">
<meta property="og:site_name" content="Ai吃橘子">
<meta property="og:description" content="MySQL基础说一下MySQL是如何执行一条SQL的？具体步骤有哪些？ Server层按顺序执行sql的步骤为：  客户端请求-&gt; 连接器（验证用户身份，给予权限） -&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt; 分析器（对SQL进行词法分析和语法分析操作） -&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt; 执行器（执行时会先看用户是">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://oss.interviewguide.cn/img/202205220024265.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_19.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_25.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_26.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_29.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_20.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_21.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_22.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_23.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_24.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_30.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_31.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_32.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_33.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_34.png">
<meta property="article:published_time" content="2023-04-17T02:43:05.000Z">
<meta property="article:modified_time" content="2023-08-18T15:10:08.440Z">
<meta property="article:tag" content="八股文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://oss.interviewguide.cn/img/202205220024265.png">


<link rel="canonical" href="http://example.com/2023/04/17/MySQL/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/04/17/MySQL/","path":"2023/04/17/MySQL/","title":"MySQL"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL | Ai吃橘子</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Ai吃橘子</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">雄关漫道真如铁，而今迈步从头越</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">1.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BMySQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1SQL%E7%9A%84%EF%BC%9F%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">说一下MySQL是如何执行一条SQL的？具体步骤有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">三大范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#drop%E3%80%81delete%E3%80%81%E5%92%8Ctruncate%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">drop、delete、和truncate区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E9%9B%86%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.4.</span> <span class="nav-text">设计数据集步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyISAM%E5%92%8CInnoDB%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.5.</span> <span class="nav-text">MyISAM和InnoDB区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1ACID%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.6.</span> <span class="nav-text">事务ACID特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.7.</span> <span class="nav-text">并发事务带来的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.1.8.</span> <span class="nav-text">事务隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.9.</span> <span class="nav-text">join的使用和原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.10.</span> <span class="nav-text">SQL语句执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#datetime%E5%92%8Ctimestamp%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.11.</span> <span class="nav-text">datetime和timestamp区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#varchar%E5%92%8Cchar%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.12.</span> <span class="nav-text">varchar和char区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#in%E5%92%8Cexists%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.13.</span> <span class="nav-text">in和exists区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">高性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">1.2.1.</span> <span class="nav-text">字段设计规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">1.2.2.</span> <span class="nav-text">索引设计规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85-100-%E4%B8%87%E8%A1%8C%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99-UPDATE-DELETE-INSERT-%E6%93%8D%E4%BD%9C-%E8%A6%81%E5%88%86%E6%89%B9%E5%A4%9A%E6%AC%A1%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.3.</span> <span class="nav-text">超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.3.</span> <span class="nav-text">索引详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.1.</span> <span class="nav-text">索引优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8HashMap"><span class="nav-number">1.3.2.</span> <span class="nav-text">索引底层数据结构？为什么不使用HashMap?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">索引类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.4.</span> <span class="nav-text">唯一索引和普通索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.5.</span> <span class="nav-text">聚集索引和非聚集索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.6.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">1.3.7.</span> <span class="nav-text">索引失效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.3.8.</span> <span class="nav-text">建立索引的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.9.</span> <span class="nav-text">联合索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">1.4.</span> <span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redo-log-%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="nav-number">1.4.1.</span> <span class="nav-text">redo log(重做日志)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#binlog"><span class="nav-number">1.4.2.</span> <span class="nav-text">binlog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">1.4.3.</span> <span class="nav-text">两阶段提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undo-log-%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97"><span class="nav-number">1.4.4.</span> <span class="nav-text">undo log(回滚日志)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC"><span class="nav-number">1.5.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.1.</span> <span class="nav-text">InnoDB对MVCC的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RC%E5%92%8CRR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8BMVCC%E7%9A%84ReadView%E7%94%9F%E6%88%90%E6%97%B6%E6%9C%BA%E4%B8%8D%E5%90%8C"><span class="nav-number">1.5.2.</span> <span class="nav-text">RC和RR隔离级别下MVCC的ReadView生成时机不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC-Next-key-Lock%E9%98%B2%E6%AD%A2%E5%B9%BB%E8%AF%BB%EF%BC%88RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%89"><span class="nav-number">1.5.3.</span> <span class="nav-text">MVCC+Next-key-Lock防止幻读（RR隔离级别）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">1.6.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%88%86%E7%B1%BB"><span class="nav-number">1.6.1.</span> <span class="nav-text">锁分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="nav-number">1.6.2.</span> <span class="nav-text">两阶段锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E5%8E%9F%E5%88%99"><span class="nav-number">1.6.3.</span> <span class="nav-text">加锁原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86"><span class="nav-number">1.7.</span> <span class="nav-text">特殊情况处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.7.1.</span> <span class="nav-text">超大分页如何处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96SQL%EF%BC%9F"><span class="nav-number">1.7.2.</span> <span class="nav-text">优化SQL？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">1.7.3.</span> <span class="nav-text">分布式主键方案？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="nav-number">1.7.4.</span> <span class="nav-text">分库分表？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">1.7.5.</span> <span class="nav-text">大表查询优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">1.7.6.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.7.</span> <span class="nav-text">主从复制同步方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E6%97%B6%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0-%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">1.7.8.</span> <span class="nav-text">Mysql主从同步延时产生原因?怎么优化？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%BD%E7%9F%A5%E9%81%93%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E9%87%87%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%EF%BC%8C%E5%8E%9F%E5%9B%A0%E4%B9%9F%E6%9C%89%E5%BE%88%E5%A4%9A%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">都知道数据库索引采用B+树而不是B树，原因也有很多，主要原因是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">MySQL中为什么要有事务回滚机制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%92%8C%E5%88%86%E8%A1%A8%E5%91%A2%EF%BC%9F%E9%83%BD%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%93%E6%88%96%E8%80%85%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%90%97%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">不可重复读和幻读区别是什么？可以举个例子吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E8%84%8F%E8%AF%BB%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%90%97%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">不可重复读和脏读区别是什么？可以举个例子吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">数据库悲观锁和乐观锁的原理和应用场景分别有什么？</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">学习记录</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/17/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai吃橘子">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL | Ai吃橘子">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-17 10:43:05" itemprop="dateCreated datePublished" datetime="2023-04-17T10:43:05+08:00">2023-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-18 23:10:08" itemprop="dateModified" datetime="2023-08-18T23:10:08+08:00">2023-08-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="说一下MySQL是如何执行一条SQL的？具体步骤有哪些？"><a href="#说一下MySQL是如何执行一条SQL的？具体步骤有哪些？" class="headerlink" title="说一下MySQL是如何执行一条SQL的？具体步骤有哪些？"></a>说一下MySQL是如何执行一条SQL的？具体步骤有哪些？</h4><p><img src="http://oss.interviewguide.cn/img/202205220024265.png" alt="SQL执行的全部过程"></p>
<p>Server层按顺序执行sql的步骤为：</p>
<ol>
<li>客户端请求-&gt;</li>
<li>连接器（验证用户身份，给予权限） -&gt;</li>
<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li>
<li>分析器（对SQL进行词法分析和语法分析操作） -&gt;</li>
<li>优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt;</li>
<li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-&gt;</li>
<li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li>
</ol>
<p>简单概括：</p>
<ul>
<li><strong>连接器</strong>：管理连接、权限验证；</li>
<li><strong>查询缓存</strong>：命中缓存则直接返回结果；</li>
<li><strong>分析器</strong>：对SQL进行词法分析、语法分析；（判断查询的SQL字段是否存在也是在这步）</li>
<li><strong>优化器</strong>：执行计划生成、选择索引；</li>
<li><strong>执行器</strong>：操作引擎、返回结果；</li>
<li><strong>存储引擎</strong>：存储数据、提供读写接口</li>
</ul>
<h4 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h4><ul>
<li>1NF：数据库每个字段都不能再分为多个字段（最基本要求），例如<strong>班级字段可分为专业和班号</strong>，<strong>解决方法拆字段</strong></li>
<li>2NF：满足1NF的情况下，在<strong>存在主键时，不能有部分依赖</strong>。(主要<strong>针对复合主键</strong>的)。例如订单号和商品号作为复合主键，商品信息只依赖商品号，<strong>解决方法是拆表</strong></li>
<li>3NF：满足1NF,2NF，确保数据库每个字段都和主键直接相关，而不是间接相关，例如学号为主键，课程号和学号并不是直接相关，<strong>解决方法是拆表</strong></li>
</ul>
<h4 id="drop、delete、和truncate区别？"><a href="#drop、delete、和truncate区别？" class="headerlink" title="drop、delete、和truncate区别？"></a>drop、delete、和truncate区别？</h4><ul>
<li>用法不同<ul>
<li>drop：删除整个表，包括表结构</li>
<li>truncate：清空整个表，保留表结构</li>
<li>delete：删除表中的某一列数据，不加条件，清空整个表，保留表结构</li>
</ul>
</li>
<li>属于不同的数据库语言<ul>
<li>truncate和drop属于DDL语言，原数据不会放入rollback segment中，无法回滚</li>
<li>delete是DML语言，会将原数据放入rollback segment中，可以回滚</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</p>
<p><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</p>
<p><code>drop</code>命令会把表占用的空间全部释放掉。</p>
</blockquote>
<h4 id="设计数据集步骤"><a href="#设计数据集步骤" class="headerlink" title="设计数据集步骤"></a>设计数据集步骤</h4><ul>
<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>
<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>
<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>
<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>
<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护</li>
</ul>
<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><ul>
<li><strong>锁</strong>：MyISAM只有表级锁；InnoDB支持表级锁和行级锁</li>
<li><strong>事务</strong>：MyISAM不支持事务；InnoDB支持事务，可以提交和回滚</li>
<li><strong>外键</strong>：MyISAM不支持外键；InnoDB支持外键</li>
<li><strong>安全恢复</strong>：MyISAM不支持异常崩溃后的安全回复；InnoDB支持，恢复的过程依赖于 <code>redo log</code></li>
<li><strong>索引结构</strong>：MyISAM索引使用B+树，叶子节点存放的是数据记录的地址，索引文件和数据文件是分开的；InnoDB索引使用B+树，叶子节点存放的是完整的数据记录，非聚簇索引存放的是主键的值</li>
</ul>
<h4 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h4><ul>
<li><p><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用</p>
</li>
<li><p><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的</p>
</li>
<li><p><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</p>
</li>
<li><p><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</p>
<blockquote>
<p>实现原理：</p>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p>
<p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>
</blockquote>
</li>
</ul>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><ul>
<li><p>脏读</p>
<p>：一个事务读取了另一个事务未提交的数据</p>
<ul>
<li>添加写锁</li>
</ul>
</li>
<li><p><strong>丢失修改</strong>：两个事务同时操作同一个数据，同时读取了数据，修改之后提交，可能有一个事务的修改操作没有生效</p>
</li>
<li><p>不可重复读</p>
<p>：在同一个事务内，多次读取同一个数据，由于其他事务对数据的修改，多次读取的数据不同</p>
<ul>
<li>给查询范围内的数据加读锁并且读取之后不会马上释放</li>
<li>其他事务无法施加写锁，无法修改数据；但是可以插入数据，导致幻读</li>
</ul>
</li>
<li><p>幻读</p>
<p>：在同一个事务内，查询同一个表中的数据，由于其他事务添加或删除数据，发现多次查询总的数据量不同</p>
<ul>
<li>间隙锁加行锁</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul>
<li><p><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更</p>
</li>
<li><p><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据</p>
</li>
<li><p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>MySQL默认隔离级别</strong></p>
</li>
<li><p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_19.png" alt="事务隔离"></p>
</li>
</ul>
<h4 id="join的使用和原理"><a href="#join的使用和原理" class="headerlink" title="join的使用和原理"></a>join的使用和原理</h4><ul>
<li><p><code>left join</code>：保留左表的数据，左表没有的数据设置为null，外连接</p>
</li>
<li><p><code>right join</code>：保留右表的数据，右表没有的数据设置为null，外连接</p>
</li>
<li><p><code>join(inner join)</code>：取左右表数据的交集，内连接</p>
</li>
<li><p>原理：嵌套循环（Nested-Loop Join），需要区分驱动表和被驱动表，先访问驱动表，筛选出结果集</p>
<ul>
<li><p>SNLJ（Simple Nested-Loop Join）：简单嵌套循环，将驱动表中的数据一行一行读取出来进行匹配，每行数据都会出发被驱动表的整表扫描，对比数据，将结果加入结果集，不需要回表</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_25.png" alt="SNLJ"></p>
</li>
<li><p>INLJ（Index Nested-Loop join）：索引嵌套循环。和SNLJ类似，最大的区别是用来join的字段在被驱动表中建立了索引，<strong>如果是非聚簇索引需要进行回表，聚簇索引不需要回表</strong></p>
<ul>
<li>SNLJ算法被驱动表需要每次全表查询，INLJ算法使用索引查询，性能提高</li>
</ul>
</li>
<li><p>BNLJ（Block Nested-Loop Join）：块嵌套循环，没有索引的情况下一种优化，降低被驱动表的扫描次数，使用join buffer缓冲区</p>
<ul>
<li>join bufffer缓存join所需的字段，在与被驱动表进行对比时，将buffer中的所有字段和被驱动表一起对比，如果buffer足够大，只需要对被驱动表查询一次</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_26.png" alt="BNLJ"></p>
</li>
</ul>
</li>
</ul>
<h4 id="SQL语句执行流程"><a href="#SQL语句执行流程" class="headerlink" title="SQL语句执行流程"></a>SQL语句执行流程</h4><p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_29.png" alt="执行流程"></p>
<h4 id="datetime和timestamp区别"><a href="#datetime和timestamp区别" class="headerlink" title="datetime和timestamp区别"></a>datetime和timestamp区别</h4><ul>
<li>共同点：存储精度都精确到秒</li>
<li>区别：<ul>
<li>datetime日期范围1001——9999年，timestamp范围为1970——2038年</li>
<li>datetime存储时间与时区无关，timestamp和时区相关</li>
<li>datetime占8个字节，timestamp占4字节</li>
<li>datetime默认值为null,timestamp默认为当前时间</li>
</ul>
</li>
</ul>
<h4 id="varchar和char区别"><a href="#varchar和char区别" class="headerlink" title="varchar和char区别"></a>varchar和char区别</h4><ul>
<li>char定长，varchar是变长的，用一个字符表示占用长度</li>
<li>检索效率char&gt;varchar，如果确认某个字段的值，使用char，例如MD5加密后的密码</li>
</ul>
<h4 id="in和exists区别"><a href="#in和exists区别" class="headerlink" title="in和exists区别"></a>in和exists区别</h4><ul>
<li>in先执行子查询，后执行主查询，exists相反。通常<strong>in+小表，exists+大表</strong>，遵循小表驱动大表原则，减少数据库连接次数</li>
</ul>
<h3 id="高性能优化"><a href="#高性能优化" class="headerlink" title="高性能优化"></a>高性能优化</h3><h4 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h4><ul>
<li><strong>优先选择符合存储需要的最小数据类型</strong>：建立索引的空间越小，一页中能够存储的索引节点数量也就越多，遍历时的IO次数就越少<ul>
<li><strong>将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></li>
</ul>
</li>
<li><strong>避免使用 TEXT,BLOB 数据类型</strong>：可以将BLOB或是TEXT列分离到单独的扩展表中，查询时只取出必要的列<ul>
<li>大数据类型不能适用内存临时表，必须使用磁盘临时表，MySQL要进行二次查询，很慢</li>
</ul>
</li>
<li><strong>避免使用ENUM类型</strong>：修改ENUM值需要使用ALTER语句，排序效率很低</li>
<li><strong>尽可能把所有列定义为NOT NULL</strong>：索引NULL列需要额外的空间，会占用更多的空间，进行计算和比较时，也需要特殊处理</li>
<li><strong>使用TIMESTAMP（4字节）或DATETIME（8字节）存储时间</strong>：不要使用字符串存储日期</li>
<li><strong>财务类相关金额数据必须使用decimal类型</strong>：精准浮点数</li>
</ul>
<h4 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h4><ul>
<li><p><strong>建议单张表的索引不超过5个</strong>：索引在增加查询效率的同时，也会降低插入和更新的效率。MySQL在进行查询操作时，会对每一个可以使用的索引进行评估，选择最优的索引进行查询，索引太多会导致计划的时间变长，降低效率</p>
</li>
<li><p>每个Innodb都必须有主键</p>
<p>：Innodb按照主键索引的顺序来组织表</p>
<ul>
<li>不使用更新频繁的列作为主键</li>
<li>不要使用UUID,MD5,HASH字符串作为主键，无法保证数据的顺序增长</li>
<li>主键建议使用自增ID值</li>
</ul>
</li>
<li><p>设置为索引的列</p>
<p>：</p>
<ul>
<li>出现在WHERE从句中的列</li>
<li>包含在ORDER BY、GROUP BY、DISTINCT中的字段</li>
<li>不要对符合前两个条件的每个列都建立索引，建立联合索引效果更好</li>
<li>多表join的关联列</li>
</ul>
</li>
<li><p>索引列的顺序</p>
<p>：</p>
<ul>
<li>区分度最高的放在联合索引的最左侧</li>
<li>字段小的索引放在联合索引的最左侧</li>
<li>使用最频繁的列放在联合索引的最左侧</li>
</ul>
</li>
<li><p>对于频繁的查询优先考虑使用覆盖索引</p>
<p>：</p>
<ul>
<li><strong>避免 Innodb 表进行索引的二次查询:</strong> 对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>
<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，顺序获取比随机获取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO</li>
</ul>
</li>
</ul>
<h4 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h4><ul>
<li><p><strong>大批量操作可能会造成严重的主从延迟</strong></p>
<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
</li>
<li><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong>：大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
</li>
<li><p><strong>避免产生大事务操作</strong>：大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>
</li>
<li><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>
</li>
</ul>
<h3 id="索引详解"><a href="#索引详解" class="headerlink" title="索引详解"></a>索引详解</h3><h4 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h4><ul>
<li>优点：大大加快数据的检索速度；通过创建唯一性索引，可以保证数据库中每一行数据的唯一性</li>
<li>缺点：<ul>
<li>创建维护索引需要耗时，对数据进行增删改查也需要改变索引</li>
<li>索引需要物理空间存储</li>
<li>数据库数据量不大时，索引不一定有很好的效果</li>
</ul>
</li>
</ul>
<h4 id="索引底层数据结构？为什么不使用HashMap"><a href="#索引底层数据结构？为什么不使用HashMap" class="headerlink" title="索引底层数据结构？为什么不使用HashMap?"></a>索引底层数据结构？为什么不使用HashMap?</h4><ul>
<li><p><code>不使用HashMap</code>：HashMap不支持顺序和范围查询，无法很快查找某个范围类的数据</p>
</li>
<li><p>使用B+树作为索引数据结构</p>
<blockquote>
<p>使用B树或B+树作为索引结构主要是为了减少磁盘IO的次数，降低二叉平衡查找树的高度，因此B树和B+树都为<strong>多路平衡查找树</strong></p>
<ul>
<li>一个m阶的B树具有如下几个特征：<ul>
<li>根结点至少有两个子女</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m</li>
<li>每一个叶子节点都包含k-1个元素，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m</li>
<li>所有的叶子结点都位于同一层</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划</li>
<li>每个结点都有卫星数据</li>
</ul>
</li>
<li>插入操作：判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可</li>
<li>一个m阶的B+树具有如下特征：<ul>
<li>有k个子树的中间节点包含有k个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点（m&#x2F;2 &lt;&#x3D; k &lt;&#x3D;m）</li>
<li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接</li>
<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素</li>
<li>根节点的最大（或最小）元素也就是整个B+树中最大（或最小）的元素，要一直保持</li>
<li>只有叶子节点有卫星数据</li>
</ul>
</li>
<li>B+树的优势：<ul>
<li>单一节点存储更多的元素，使得查询的IO次数更少</li>
<li>所有查询都要查找到叶子节点，查询性能稳定</li>
<li>所有叶子节点形成有序链表，便于范围查询</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>MyISAM中，B+树叶节点的data域中存放的是数据记录的地址，取出data域的值后，还需要根据相应的地址取出相应的数据记录，这被称为<code>非聚簇索引</code></p>
</li>
<li><p>InnoDB中，其数据本身就是索引文件，树的叶节点data域保存了完整的数据记录，这被称为<code>聚簇索引</code>，这个索引的key是数据表的主键，而其余的索引都是辅助索引。辅助索引的data域存的是主键的值。</p>
<ul>
<li>根据主索引查找时，可以直接取出查找的数据</li>
<li>根据辅助索引查找时，首先查询到主键的值，再走主索引取出相应的值</li>
</ul>
</li>
</ul>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul>
<li><p><strong>主键索引</strong>：主键列使用的索引。InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键</p>
</li>
<li><p>二级索引（辅助索引）</p>
<p>：</p>
<ul>
<li>唯一索引：唯一索引的属性列<strong>不能出现重复的数据</strong>，允许数据为NULL，一张表可以创建多个唯一索引。一般是为了数据的唯一性，而不是为了查询效率</li>
<li>普通索引：为了快速查询数据，可以创建多个普通索引，允许数据重复和NULL</li>
<li>前缀索引：只适用于字符串数据，对文本的前几个字符创建的索引，相比普通索引建立的数据更小，<strong>会导致覆盖索引优化失效</strong></li>
<li>全文索引：为了检索大文本数据中的关键字信息</li>
</ul>
</li>
</ul>
<h4 id="唯一索引和普通索引"><a href="#唯一索引和普通索引" class="headerlink" title="唯一索引和普通索引"></a>唯一索引和普通索引</h4><ul>
<li><p>二者查询性能差不多。主要区别在于更新的记录目标页不在内存中时，<strong>普通索引</strong>更新会使用change Buffer。<strong>唯一索引</strong>，由于需要校验数据的唯一性，因此每次更新操作都需要读磁盘把数据载进内存，涉及IO操作</p>
<ul>
<li>在不影响数据一致性的前提下， InnoDB会将这些更新操作缓存在change buffer中， 这样就不需要从磁盘中读入这个数据页了。 在下次查询需要访问这个数据页的时候， 将数据页读入内存， 然后执行change buffer中与这个页有关的操作。 通过这种方式就能保证这个数据逻辑的正确性</li>
<li>change buffer中的操作应用到原数据页，得到最新结果的过程称为merge<ol>
<li>访问这个数据页会触发merge。</li>
<li>系统有后台线程会定期merge。</li>
<li>在数据库正常关闭（shutdown） 的过程中，也会执行merge操作</li>
</ol>
</li>
</ul>
<blockquote>
<p>change Buffer与redo log 区别</p>
<ul>
<li>change Buffer主要用于减少读磁盘的次数，在必要读磁盘时再更新数据。</li>
<li>redo log 则是减少内存更新后，写磁盘的次数</li>
</ul>
<p>merge的执行流程是这样的：</p>
<ol>
<li>从磁盘读入数据页到内存（老版本的数据页）；</li>
<li>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；</li>
<li>写redo log。这个redo log包含了数据的变更和change buffer的变更</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><ul>
<li><p>聚集索引</p>
<p>：索引结构和数据一起存放的索引。主键索引属于聚集索引，物理地址连续</p>
<ul>
<li>优点：查询速度快，不需要进行二次查询</li>
<li>缺点：<ul>
<li>依赖于有序的数据：如果索引的数据不是有序的，需要在插入时排序</li>
<li>更新代价大：被索引的列进行修改时，对应的索引也要修改，而叶子节点也包含着数据，也要更新，代价比较大。所以对于主键索引来说，一般不可被修改</li>
</ul>
</li>
</ul>
</li>
<li><p>非聚集索引</p>
<p>：索引结构和数据分开存放的索引。二级索引属于非聚集索引，逻辑上连续，物理地址不连续</p>
<ul>
<li>优点：更新代价比聚集索引小</li>
<li>缺点：<ul>
<li>依赖于有序的数据</li>
<li>可能会产生二次查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>非聚集索引不一定回表查询：查询的字段刚好建立了索引，直接返回就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM table WHERE name=&#x27;guang19&#x27;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><ul>
<li>一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作</li>
</ul>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul>
<li>where语句中包含or时，可能会导致索引失效<ul>
<li>若or的条件中包含非索引，就会只用全表扫描的。如果or的条件两边都是索引，那么会使用<code>index_merge</code>的优化技术</li>
<li>index_merge：<strong>对多个索引分别进行条件扫描，然后将它们各自的结果进行合并</strong></li>
</ul>
</li>
<li>where语句中索引列使用了负向查询，可能会导致索引失效<ul>
<li>负向查询包括：NOT、!&#x3D;、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等</li>
</ul>
</li>
<li>对索引列进行<strong>运算</strong>，一定会导致索引失效</li>
<li>在索引列上使用<strong>内置函数</strong>，一定会导致索引失效</li>
<li>like通配符可能会导致索引失效，未满足最左匹配原则。</li>
<li>隐式类型转换导致的索引失效，如索引列user_id为varchar类型，使用int做条件关联。或者关联表字符集编码不一致。</li>
<li>索引字段可以为null，使用is null或is not null时，可能会导致索引失效</li>
<li>联合索引未满足最左匹配原则</li>
</ul>
<h4 id="建立索引的注意事项"><a href="#建立索引的注意事项" class="headerlink" title="建立索引的注意事项"></a>建立索引的注意事项</h4><ul>
<li><strong>选择合适的字段创建索引：</strong><ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
</li>
<li><strong>被频繁更新的字段应该慎重建立索引</strong>：虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</li>
<li><strong>尽可能的考虑建立联合索引而不是单列索引</strong>：因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</li>
<li><strong>注意避免冗余索引</strong>：冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</li>
<li><strong>考虑在字符串类型的字段上使用前缀索引代替普通索引</strong>：前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引</li>
</ul>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><ul>
<li>最左匹配原则：查询条件中必须要有联合索引的第一个字段才可以使用索引</li>
<li>索引覆盖：不满足最左匹配原则的情况下，如果查询的字段都在联合索引中，也可以使用到索引，并且不需要回表操作</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><ul>
<li><p>InnoDB独有，在系统崩溃时可以通过<code>redo log</code>恢复数据</p>
</li>
<li><p>MySQL中，查询记录是会一次将一页的信息都查询出来，加载到<code>Buffer Pool</code>中，后续查询都在<code>Buffer Pool</code>中进行，减少IO开销，更新数据也会在<code>Buffer Pool</code>中更新。然后会把在这个数据页上所做的修改，记录到<code>redo log buffer</code>中，接着刷盘到<code>redo log</code>文件中</p>
<blockquote>
<p>理想情况下，事务一提交就会进行刷盘，但实际情况下，刷盘的实际是根据策略来进行的</p>
<p>每条redo记录由<code>表空间号+数据页号+偏移量+修改数据长度+具体修改数据</code>组成</p>
</blockquote>
</li>
<li><p><strong>刷盘时机</strong>：通过设置<code>innodb_flush_log_at_trx_commit</code>参数，支持三种策略</p>
<ul>
<li>0：每次事务提交时不进行刷盘操作，宕机或者崩溃可能会有1秒的数据损失</li>
<li>1：每次事务提交时进行刷盘操作（默认），不会有数据损失</li>
<li>2：每次事务提交时，只把redo log buffer内容写入page cache，MySQL崩溃不会有损失，宕机可能会有一秒损失</li>
<li>除此之外，InnoDB引擎有一个后台线程，每隔1秒，会把<code>redo log buffer</code>中的内容写入文件系统缓存（page cache）中，然后调用<code>fsync</code>进行刷盘。当<code>redo log buffer</code>占用空间即将达到<code>innodb_log_buffer_size</code>一半时，后台线程也会主动刷盘</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_20.png" alt="刷盘"></p>
</li>
<li><p><strong>日志文件组</strong>：硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的</p>
<ul>
<li><strong>write pos</strong> ：当前记录的位置，一边写一边后移</li>
<li><strong>checkpoint</strong> ：当前要擦除的位置，也是往后推移</li>
<li>每次刷盘写入日志时，write pos会后移；每次MySQL加载日志文件组恢复数据时，会清空加载过的<code>redo log</code>，checkpoint会后移</li>
</ul>
</li>
</ul>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><ul>
<li><p>binlog是逻辑日志，记录内容是语句的原始逻辑，属于<code>MySQL Server</code>层。不管使用什么引擎，只要发生表更新，都会产生binlog。<strong>主要用于主从复制和数据恢复</strong></p>
</li>
<li><p><strong>三种格式</strong>：</p>
<ul>
<li>statement：记录SQL语句原文</li>
<li>row：记录SQL原句和操作的具体数据，比较占用空间</li>
<li>mixed：statement和row的混合，如果SQL语句会引起数据不一致，使用row；否则，使用statement</li>
</ul>
</li>
<li><p><strong>写入时机</strong>：事务执行过程中，先将日志写到binlog cache，事务提交时，再将binlog cache写入binlog文件中。</p>
<ul>
<li><p>一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code></p>
</li>
<li><p>设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync_binlog</span><br></pre></td></tr></table></figure>

<p>控制刷盘时机：</p>
<ul>
<li>0：每次提交事务只write，系统自行判断执行fsync</li>
<li>1：每次提交事务都fsync</li>
<li>N：累计N个事务再执行fsync</li>
</ul>
</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_21.png" alt="binlog"></p>
</li>
</ul>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><ul>
<li><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力；<code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性，但二者的写入时机不同</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_22.png" alt="写入时机"></p>
</li>
<li><p>为了防止binlog和redo log数据不一致，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>两个阶段</p>
<ul>
<li>在使用<code>redo log</code>恢复数据时，如果发现redo log还处于 prepare阶段，并且没有对应的binlog，就会回滚该事务</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_23.png" alt="两阶段提交"></p>
</li>
</ul>
<h4 id="undo-log-回滚日志"><a href="#undo-log-回滚日志" class="headerlink" title="undo log(回滚日志)"></a>undo log(回滚日志)</h4><ul>
<li>保证事务的原子性，所有事务的修改都会先记录到undo log中，在执行相关操作。回滚日志会优先于数据持久化到磁盘上，宕机也可以回滚</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="InnoDB对MVCC的实现"><a href="#InnoDB对MVCC的实现" class="headerlink" title="InnoDB对MVCC的实现"></a>InnoDB对MVCC的实现</h4><ul>
<li><p>通过隐藏字段、Read View和undo log实现MVCC</p>
<ul>
<li>隐藏字段：每行数据有三个隐藏字段<ul>
<li><code>DB_TRX_ID</code>：最后一次插入或者更新该行的事务id</li>
<li><code>DB_ROLL_PTR</code>：回滚指针，指向改行的undo log</li>
<li><code>DB_ROW_ID</code>：没有主键且没有唯一非空索引的情况下，<code>InnoDB</code>会使用该id生成聚簇索引</li>
</ul>
</li>
<li>ReadView：主要用来做可见性判断，保存了当前对本事务不可见的其他活跃事务<ul>
<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>
<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>
<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>
</ul>
</li>
<li>undo log：若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li>
</ul>
</li>
<li><p>数据可见性算法</p>
<p>：本次事务中读取某一行的数据</p>
<ul>
<li>如果<code>DB_TRX_ID</code>&lt;<code>m_up_limit_id</code>，则可见</li>
<li>如果<code>DB_TRX_ID</code>&gt;&#x3D;<code>m_low_limit_id</code>，表明事务快照之后才出现这一行数据，不可见</li>
<li><code>m_ids</code>为空，表示当前事务是最新的事务，可见</li>
<li>如果<code>m_up_limit_id</code>&lt;&#x3D;<code>DB_TRX_ID</code>&lt;<code>m_low_limit_id</code>，若该事务id存在m_ids中，则不可见，否则可见</li>
<li>如果事务不可见，可以通过<code>DB_ROLL_PTR</code>指针，查询该行的历史数据是否可见</li>
</ul>
</li>
</ul>
<h4 id="RC和RR隔离级别下MVCC的ReadView生成时机不同"><a href="#RC和RR隔离级别下MVCC的ReadView生成时机不同" class="headerlink" title="RC和RR隔离级别下MVCC的ReadView生成时机不同"></a>RC和RR隔离级别下MVCC的ReadView生成时机不同</h4><ul>
<li>RC下，每次查询前都要生成一个ReadView</li>
<li>RR下，只有第一次查询生成一个ReadView</li>
</ul>
<h4 id="MVCC-Next-key-Lock防止幻读（RR隔离级别）"><a href="#MVCC-Next-key-Lock防止幻读（RR隔离级别）" class="headerlink" title="MVCC+Next-key-Lock防止幻读（RR隔离级别）"></a>MVCC+Next-key-Lock防止幻读（RR隔离级别）</h4><ul>
<li>执行普通的select语句：为快照读，只在第一次查询时生成ReadView，后续事务提交不影响，可以解决幻读</li>
<li>执行select…for update&#x2F;lock in share mode、insert、update、delete等语句：为锁定读，读取的是最新的数据。InnoDB使用Next-key-Lock锁定读取到的记录以及它们之间的间隙，防止其他事务在查询范围内插入数据，防止了幻读</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_24.png" alt="SQL语句执行流程"></p>
<blockquote>
<ul>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</li>
<li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</li>
</ul>
</blockquote>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><ul>
<li><p>全局锁：对整个数据库实例加锁，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock (FTWRL)</span><br></pre></td></tr></table></figure>

<ul>
<li>应用场景：全库逻辑备份</li>
</ul>
</li>
<li><p>表锁：分为表锁和元数据锁</p>
<ul>
<li><p>表锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock tables t1 read,t2 write</span><br></pre></td></tr></table></figure>

<ul>
<li>对其他线程来说，t1表，可以读，不可以写；t2表，读写都不可以</li>
<li>对本线程来说，t1表只能读，t2表只能读写</li>
</ul>
</li>
<li><p>元数据锁：Metadata Lock(MDL)，面向DML和DDL之间得并发控制，元数据锁不需要我们显式的加，系统默认会加</p>
<ul>
<li>当做DML操作时，会申请一个MDL读锁</li>
<li>当做DDL操作时，会申请一个MDL写锁</li>
<li>读锁之间不互斥，读写和写写之间都互斥</li>
</ul>
</li>
</ul>
</li>
<li><p>行锁：InnoDB的行锁是针对索引加的，而不是针对记录，该索引不能失效，否则会升级为表锁</p>
<ul>
<li><code>select * from t lock in share mode</code></li>
</ul>
</li>
</ul>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><ul>
<li><p>在InnoDB事务中， 行锁是在需要的时候才加上的， 但并不是不需要了就立刻释放， 而是要等到事务结束时才释放</p>
<ul>
<li>事务B要在事务A提交之后才会执行</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_30.png" alt="示例"></p>
</li>
<li><p>出现死锁：</p>
<ul>
<li>进入等待，超时</li>
<li>发起死锁检测，回滚死锁链中的某一个事务，打破死锁</li>
</ul>
</li>
</ul>
<h4 id="加锁原则"><a href="#加锁原则" class="headerlink" title="加锁原则"></a>加锁原则</h4><ul>
<li>原则1： 加锁的基本单位是next-keylock，前开后闭区间</li>
<li>原则2： 查找过程中访问到的对象才会加锁</li>
<li>优化1： 索引上的等值查询， 给唯一索引加锁的时候， next-keylock退化为行锁</li>
<li>优化2： 索引上的等值查询， 向右遍历时且最后一个值不满足等值条件的时候， next-key lock退化为间隙锁。</li>
<li>一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<h3 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h3><h4 id="超大分页如何处理？"><a href="#超大分页如何处理？" class="headerlink" title="超大分页如何处理？"></a>超大分页如何处理？</h4><ul>
<li>使用主键id优化，找到上次分页的最大ID，利用主键索引进行查询。<strong>要求ID必须是连续的</strong></li>
<li>覆盖索引优化，先查出索引的主键ID，再使用主键索引拿数据</li>
</ul>
<h4 id="优化SQL？"><a href="#优化SQL？" class="headerlink" title="优化SQL？"></a>优化SQL？</h4><ul>
<li>添加合适索引：索引创建原则</li>
<li>优化表结构：数据类型越小越好、尽量少使用NULL</li>
<li>优化查询语句：是否命中索引等</li>
</ul>
<h4 id="分布式主键方案？"><a href="#分布式主键方案？" class="headerlink" title="分布式主键方案？"></a>分布式主键方案？</h4><ul>
<li>数据库自增序列</li>
<li>UUID</li>
<li>Redis生成ID</li>
<li>等</li>
</ul>
<h4 id="分库分表？"><a href="#分库分表？" class="headerlink" title="分库分表？"></a>分库分表？</h4><ul>
<li><p>分表：单表数据量过大，会影响查询性能。将一个表的数据放在多个表中</p>
<ul>
<li><p>垂直分表：把一个表的多个字段拆分为多个表，一般将字段作冷热拆分，冷字段一个表，热字段一个表</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_31.png" alt="垂直分表案例"></p>
</li>
<li><p>水平分表：减少单个表中的数据量</p>
</li>
</ul>
</li>
<li><p>分库：单库的并发量最多到2000，将一个库的数据拆分到多个库中，可以增加并发量</p>
<ul>
<li><p>垂直分库：将关联度低的表存放在不同的库中</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_32.png" alt="垂直分库案例"></p>
</li>
<li><p>水平分库：提升单个业务系统的QPS</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_33.png" alt="水平分库案例"></p>
</li>
</ul>
</li>
<li><p>垂直切分的优缺点：</p>
<ul>
<li>优点：切合业务系统结构；方便对数据进行管理；提升系统的高并发性能</li>
<li>缺点：没有解决单表数据量过大的问题；分布式事务处理复杂</li>
</ul>
</li>
<li><p>水平切分的优缺点：</p>
<ul>
<li>优点：提升系统性能，不存在性能瓶颈；对业务没有影响</li>
<li>缺点：数据多次扩展难度和维护大</li>
</ul>
</li>
</ul>
<h4 id="大表查询优化"><a href="#大表查询优化" class="headerlink" title="大表查询优化"></a>大表查询优化</h4><ul>
<li>优化sql语句，增加索引</li>
<li>增加缓存，使用redis</li>
<li>主从复制，读写分离</li>
<li>分库分表</li>
</ul>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_34.png" alt="主从复制过程"></p>
<ul>
<li><ol>
<li>Master的更新事件(update、insert、delete)会按照顺序写入bin-log中。当Slave连接到Master的后,Master机器会为Slave开启 binlog dump线程,该线程会去读取bin-log日志</li>
<li>Slave连接到Master后,Slave库有一个I&#x2F;O线程 通过请求binlog dump thread读取bin-log日志,然后写入从库的relay log日志中。</li>
<li>Slave还有一个 SQL线程,实时监控 relay-log日志内容是否有更新,解析文件中的SQL语句,在Slave数据库中去执行。</li>
</ol>
</li>
</ul>
<h4 id="主从复制同步方式"><a href="#主从复制同步方式" class="headerlink" title="主从复制同步方式"></a>主从复制同步方式</h4><ul>
<li><strong>异步复制</strong> ：Mysql主从同步 默认是异步复制的。就是上面三步中,只有第一步是同步的(也就是Mater写入bin log日志),就是主库写入binlog日志后即可成功返回客户端，无须等待binlog日志传递给从库的过程。 Master 不关心 Slave 的数据有没有写入成功。因此如果Master和Slave之间有网络延迟，就会造成暂时的数据不一致的现象；如果Master出故障，而数据还没有复制过去，则会造成数据丢失；但也有好处，<strong>效率较其他两种复制方式最高</strong>。</li>
<li><strong>同步复制</strong> ：Master主机将事件发送给Slave主机后会触发一个等待，直到所有Slave节点（如果有多个Slave）返回数据复制成功的信息给Master。 这种复制方式最安全，但是同时，效率也是最差的。</li>
<li><strong>半同步复制</strong> ：对于半同步复制而言，Master主机将事件发送给Slave主机后会触发一个等待，直到其中一个Slave节点（如果有多个Slave）返回数据复制成功的信息给Master。 由此增强了数据的一致性，但是因为Master主机的确认开销，会损耗一部分的性能； 另外，半同步复制除了不需要等待所有Slave主机确认事件的接收外，半同步数据复制并不要求那些事件完全地执行，因此，仍有可能看到在Slave主机上数据复制延迟的发生，如果因为网络延迟等原因造成Slave迟迟没有返回复制成功的信息，超过了Master设置的超时时长，<strong>半同步复制就降级为异步复制方式</strong>，而后继续数据复制。</li>
</ul>
<h4 id="Mysql主从同步延时产生原因-怎么优化？"><a href="#Mysql主从同步延时产生原因-怎么优化？" class="headerlink" title="Mysql主从同步延时产生原因?怎么优化？"></a>Mysql主从同步延时产生原因?怎么优化？</h4><ul>
<li>原因：<ul>
<li>主节点如果执行一个很大的事务，会对主从延迟产生较大的影响</li>
<li>网络延迟，日志较大，slave数量过多</li>
<li>机器性能问题，从节点是否使用了“烂机器”</li>
</ul>
</li>
<li>优化：<ul>
<li>大事务：将大事务分为小事务，分批更新数据</li>
<li>减少Slave的数量，不要超过5个，减少单次事务的大小</li>
</ul>
</li>
</ul>
<h2 id="都知道数据库索引采用B-树而不是B树，原因也有很多，主要原因是什么？"><a href="#都知道数据库索引采用B-树而不是B树，原因也有很多，主要原因是什么？" class="headerlink" title="都知道数据库索引采用B+树而不是B树，原因也有很多，主要原因是什么？"></a>都知道数据库索引采用B+树而不是B树，原因也有很多，主要原因是什么？</h2><p>主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低</p>
<p>文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。</p>
<p>最重要的是，B+树还有一个最大的好处：方便扫库。</p>
<p>B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。</p>
<p>B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。</p>
<p>B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；</p>
<p>B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；</p>
<h2 id="MySQL中为什么要有事务回滚机制？"><a href="#MySQL中为什么要有事务回滚机制？" class="headerlink" title="MySQL中为什么要有事务回滚机制？"></a>MySQL中为什么要有事务回滚机制？</h2><p>而在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入。 当事务已经被提交之后，就无法再次回滚了。</p>
<p>回滚日志作用： 1)能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息 2) 在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。</p>
<h2 id="数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？"><a href="#数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？" class="headerlink" title="数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？"></a>数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？</h2><p>分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。</p>
<p><strong>通过分表</strong>，可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用，此外，可以很大的缓解表锁的问题。 分表策略可以归纳为垂直拆分和水平拆分： <strong>水平分表</strong>：取模分表就属于随机分表，而时间维度分表则属于连续分表。 如何设计好垂直拆分，我的建议：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。 对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。</p>
<p><strong>库内分表</strong>，仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等。</p>
<p><strong>分库与分表带来的分布式困境与应对之策</strong> 数据迁移与扩容问题—-一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。 分页与排序问题—-需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。</p>
<h2 id="不可重复读和幻读区别是什么？可以举个例子吗？"><a href="#不可重复读和幻读区别是什么？可以举个例子吗？" class="headerlink" title="不可重复读和幻读区别是什么？可以举个例子吗？"></a>不可重复读和幻读区别是什么？可以举个例子吗？</h2><p><strong>不可重复读的重点是修改，幻读的重点在于新增或者删除。</strong></p>
<ul>
<li><p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
</li>
<li><p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记 录就变为了5条，这样就导致了幻读。</p>
</li>
</ul>
<h2 id="不可重复读和脏读区别是什么？可以举个例子吗？"><a href="#不可重复读和脏读区别是什么？可以举个例子吗？" class="headerlink" title="不可重复读和脏读区别是什么？可以举个例子吗？"></a>不可重复读和脏读区别是什么？可以举个例子吗？</h2><ol>
<li><p>**不可重复读 (Non-repeatable Read)**： 不可重复读是指在一个事务内，同一个查询在不同时间点多次执行，但返回的结果不一致。这是由于在事务执行期间，其他事务可能修改了相同的数据，导致不同的查询返回不同的结果。这可能会导致数据的不一致性。</p>
<p>示例：</p>
<ul>
<li>事务 A 查询某个记录的值为 X。</li>
<li>事务 B 修改了该记录的值为 Y，并提交。</li>
<li>事务 A 再次查询同一个记录，发现其值变为了 Y，与之前的查询结果不同。</li>
</ul>
</li>
<li><p>**脏读 (Dirty Read)**： 脏读是指一个事务读取了另一个事务未提交的数据。换句话说，脏读就是读取了还未生效的数据，这可能会导致错误的信息传递和不一致性。</p>
<p>示例：</p>
<ul>
<li>事务 A 修改某个记录的值，但未提交。</li>
<li>事务 B 读取了事务 A 修改后的值，然后事务 A 回滚了，撤销了之前的修改。</li>
<li>此时事务 B 所读取的值实际上是无效的、未提交的数据，称为脏数据。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li>“不可重复读” 是指一个事务内相同查询在不同时间点返回不同结果，因为其他事务修改了相同数据。</li>
<li>“脏读” 是指一个事务读取了另一个事务未提交的数据，可能会导致读取到无效或错误的数据。</li>
</ul>
<h2 id="数据库悲观锁和乐观锁的原理和应用场景分别有什么？"><a href="#数据库悲观锁和乐观锁的原理和应用场景分别有什么？" class="headerlink" title="数据库悲观锁和乐观锁的原理和应用场景分别有什么？"></a>数据库悲观锁和乐观锁的原理和应用场景分别有什么？</h2><p>悲观锁，先获取锁，再进行业务操作，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。 当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p>
<p>乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag"># 八股文</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87/" rel="prev" title="操作系统八股文">
                  <i class="fa fa-chevron-left"></i> 操作系统八股文
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/04/18/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" rel="next" title="LeetCode刷题记录">
                  LeetCode刷题记录 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
