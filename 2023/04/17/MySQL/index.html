<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="MySQL基础说一下MySQL是如何执行一条SQL的？具体步骤有哪些？ Server层按顺序执行sql的步骤为：  客户端请求-&gt; 连接器（验证用户身份，给予权限） -&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt; 分析器（对SQL进行词法分析和语法分析操作） -&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt; 执行器（执行时会先看用户是">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://example.com/2023/04/17/MySQL/index.html">
<meta property="og:site_name" content="Ai吃橘子">
<meta property="og:description" content="MySQL基础说一下MySQL是如何执行一条SQL的？具体步骤有哪些？ Server层按顺序执行sql的步骤为：  客户端请求-&gt; 连接器（验证用户身份，给予权限） -&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt; 分析器（对SQL进行词法分析和语法分析操作） -&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt; 执行器（执行时会先看用户是">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://oss.interviewguide.cn/img/202205220024265.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_19.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_25.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_26.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_29.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_20.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_21.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_22.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_23.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_24.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_30.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_31.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_32.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_33.png">
<meta property="og:image" content="https://hehemagic.github.io/2022/01/03/day29/day29_34.png">
<meta property="article:published_time" content="2023-04-17T02:43:05.000Z">
<meta property="article:modified_time" content="2023-08-28T04:57:45.161Z">
<meta property="article:tag" content="八股文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://oss.interviewguide.cn/img/202205220024265.png">


<link rel="canonical" href="http://example.com/2023/04/17/MySQL/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/04/17/MySQL/","path":"2023/04/17/MySQL/","title":"MySQL"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL | Ai吃橘子</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Ai吃橘子</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">雄关漫道真如铁，而今迈步从头越</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL"><span class="nav-number">1.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BMySQL%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1SQL%E7%9A%84%EF%BC%9F%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">说一下MySQL是如何执行一条SQL的？具体步骤有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">三大范式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#drop%E3%80%81delete%E3%80%81%E5%92%8Ctruncate%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">drop、delete、和truncate区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E9%9B%86%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.4.</span> <span class="nav-text">设计数据集步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MyISAM%E5%92%8CInnoDB%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.5.</span> <span class="nav-text">MyISAM和InnoDB区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1ACID%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.6.</span> <span class="nav-text">事务ACID特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.7.</span> <span class="nav-text">并发事务带来的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.1.8.</span> <span class="nav-text">事务隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.9.</span> <span class="nav-text">join的使用和原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.10.</span> <span class="nav-text">SQL语句执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#datetime%E5%92%8Ctimestamp%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.11.</span> <span class="nav-text">datetime和timestamp区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#varchar%E5%92%8Cchar%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.12.</span> <span class="nav-text">varchar和char区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#in%E5%92%8Cexists%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.13.</span> <span class="nav-text">in和exists区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">高性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">1.2.1.</span> <span class="nav-text">字段设计规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">1.2.2.</span> <span class="nav-text">索引设计规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85-100-%E4%B8%87%E8%A1%8C%E7%9A%84%E6%89%B9%E9%87%8F%E5%86%99-UPDATE-DELETE-INSERT-%E6%93%8D%E4%BD%9C-%E8%A6%81%E5%88%86%E6%89%B9%E5%A4%9A%E6%AC%A1%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.3.</span> <span class="nav-text">超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.3.</span> <span class="nav-text">索引详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.1.</span> <span class="nav-text">索引优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8HashMap"><span class="nav-number">1.3.2.</span> <span class="nav-text">索引底层数据结构？为什么不使用HashMap?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">索引类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.4.</span> <span class="nav-text">唯一索引和普通索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.5.</span> <span class="nav-text">聚集索引和非聚集索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.6.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">1.3.7.</span> <span class="nav-text">索引失效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.3.8.</span> <span class="nav-text">建立索引的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">1.3.9.</span> <span class="nav-text">联合索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">1.4.</span> <span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redo-log-%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="nav-number">1.4.1.</span> <span class="nav-text">redo log(重做日志)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#binlog"><span class="nav-number">1.4.2.</span> <span class="nav-text">binlog</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">1.4.3.</span> <span class="nav-text">两阶段提交</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undo-log-%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97"><span class="nav-number">1.4.4.</span> <span class="nav-text">undo log(回滚日志)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC"><span class="nav-number">1.5.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.1.</span> <span class="nav-text">InnoDB对MVCC的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RC%E5%92%8CRR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8BMVCC%E7%9A%84ReadView%E7%94%9F%E6%88%90%E6%97%B6%E6%9C%BA%E4%B8%8D%E5%90%8C"><span class="nav-number">1.5.2.</span> <span class="nav-text">RC和RR隔离级别下MVCC的ReadView生成时机不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVCC-Next-key-Lock%E9%98%B2%E6%AD%A2%E5%B9%BB%E8%AF%BB%EF%BC%88RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%89"><span class="nav-number">1.5.3.</span> <span class="nav-text">MVCC+Next-key-Lock防止幻读（RR隔离级别）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">1.6.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E5%88%86%E7%B1%BB"><span class="nav-number">1.6.1.</span> <span class="nav-text">锁分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="nav-number">1.6.2.</span> <span class="nav-text">两阶段锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E5%8E%9F%E5%88%99"><span class="nav-number">1.6.3.</span> <span class="nav-text">加锁原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E5%A4%84%E7%90%86"><span class="nav-number">1.7.</span> <span class="nav-text">特殊情况处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.7.1.</span> <span class="nav-text">超大分页如何处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96SQL%EF%BC%9F"><span class="nav-number">1.7.2.</span> <span class="nav-text">优化SQL？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="nav-number">1.7.3.</span> <span class="nav-text">分布式主键方案？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="nav-number">1.7.4.</span> <span class="nav-text">分库分表？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">1.7.5.</span> <span class="nav-text">大表查询优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">1.7.6.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.7.</span> <span class="nav-text">主从复制同步方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E6%97%B6%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0-%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">1.7.8.</span> <span class="nav-text">Mysql主从同步延时产生原因?怎么优化？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E4%BA%86%E8%A7%A3MySQL%E7%9A%84%E5%86%85%E9%83%A8%E6%9E%84%E9%80%A0%E5%90%97%EF%BC%9F%E4%B8%80%E8%88%AC%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%93%AA%E4%B8%A4%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">你了解MySQL的内部构造吗？一般可以分为哪两个部分？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%BD%E7%9F%A5%E9%81%93%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E9%87%87%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%EF%BC%8C%E5%8E%9F%E5%9B%A0%E4%B9%9F%E6%9C%89%E5%BE%88%E5%A4%9A%EF%BC%8C%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">都知道数据库索引采用B+树而不是B树，原因也有很多，主要原因是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%B4%A2%E5%BC%95%E8%A6%81%E4%BD%BF%E7%94%A8B-%E6%A0%91%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%E6%88%96%E8%80%85%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">为什么MySQL索引要使用B+树，而不是B树或者红黑树？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A2%E7%84%B6Hash%E6%AF%94B-%E6%A0%91%E6%9B%B4%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%94%A8B-%E6%A0%91%E6%9D%A5%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">既然Hash比B+树更快，为什么MySQL用B+树来存储索引呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">关系型和非关系型数据库的区别你了解多少？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">什么是非关系型数据库？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8EInnoDB%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">数据库引擎InnoDB与MyISAM的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM%E5%92%8CInnoDB%E5%AE%9E%E7%8E%B0B-%E6%A0%91%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">MyISAM和InnoDB实现B+树索引方式的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%87%AA%E5%A2%9Eid%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">InnoDB为什么要用自增id作为主键？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">MySQL中为什么要有事务回滚机制？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%88%86%E5%BA%93%E5%92%8C%E5%88%86%E8%A1%A8%E5%91%A2%EF%BC%9F%E9%83%BD%E6%94%BE%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%93%E6%88%96%E8%80%85%E4%B8%80%E5%BC%A0%E8%A1%A8%E4%B8%AD%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%90%97%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%B8%B8%E7%94%A8%E7%9A%84%E6%89%8B%E6%AE%B5%E5%B0%B1%E6%98%AF%E6%8A%8A%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8B%86%E5%88%86%EF%BC%8C%E5%85%B3%E4%BA%8E%E6%8B%86%E5%88%86%E6%95%B0%E6%8D%AE%E8%A1%A8%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于拆分数据表你了解哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">数据库并发事务会带来哪些问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%90%97%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">不可重复读和幻读区别是什么？可以举个例子吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E8%84%8F%E8%AF%BB%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E5%90%97%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">不可重复读和脏读区别是什么？可以举个例子吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">17.</span> <span class="nav-text">数据库隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">数据库悲观锁和乐观锁的原理和应用场景分别有什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4Drop%E3%80%81Delete%E4%B8%8ETruncate%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">说一说Drop、Delete与Truncate的共同点和区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE%E4%BD%9C%E7%94%A8"><span class="nav-number">20.</span> <span class="nav-text">数据库中的视图作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">为什么使用索引？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A2%E7%84%B6%E7%B4%A2%E5%BC%95%E6%9C%89%E9%82%A3%E4%B9%88%E5%A4%9A%E4%BC%98%E7%82%B9%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E7%9A%84%E6%AF%8F%E4%B8%80%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">既然索引有那么多优点，为什么不对表的每一列创建一个索引呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E7%B4%A2%E5%BC%95%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">MySQL索引都有哪些分类？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%97%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">创建索引时需要注意什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">25.</span> <span class="nav-text">MySQL 索引使用的注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%BB%E9%94%AE%E3%80%81%E8%B6%85%E9%94%AE%E3%80%81%E5%80%99%E9%80%89%E9%94%AE%E3%80%81%E5%A4%96%E9%94%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">数据库中的主键、超键、候选键、外键是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E9%9A%94%E7%A6%BB%E6%80%A7%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9F"><span class="nav-number">27.</span> <span class="nav-text">事务四大特性（ACID）原子性、一致性、隔离性、持久性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">数据库如何保证一致性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">数据库如何保证原子性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">数据库如何保证持久性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81%E5%90%A7"><span class="nav-number">31.</span> <span class="nav-text">说一下数据库表锁和行锁吧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8EMySQL%E6%9D%A5%E8%AF%B4%EF%BC%8Cselect%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E8%A1%8C%E9%94%81%E8%BF%98%E6%98%AF%E8%A1%A8%E9%94%81%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">对于MySQL来说，select使用的是行锁还是表锁？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QL%E8%AF%AD%E6%B3%95%E4%B8%AD%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E8%87%AA%E8%BF%9E%E6%8E%A5%E3%80%81%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%88%E5%B7%A6%E3%80%81%E5%8F%B3%E3%80%81%E5%85%A8%EF%BC%89%E3%80%81%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">33.</span> <span class="nav-text">QL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96%E7%9A%84%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">你知道哪些数据库结构优化的手段？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%BC%98%E5%8C%96%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%88%B0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">MySQL优化了解吗？说一下从哪些方面可以做到性能优化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E4%B8%AD%E7%9A%84NOW-%E5%92%8CCURRENT-DATE-%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E4%B8%ADCHAR%E5%92%8CVARCHAR%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">37.</span> <span class="nav-text">MySQL中CHAR和VARCHAR的区别有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%B9%B6%E5%8F%91%E6%98%AF%E6%88%91%E4%BB%AC%E7%BB%8F%E5%B8%B8%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%EF%BC%8C%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%90%97%EF%BC%9F"><span class="nav-number">38.</span> <span class="nav-text">数据库高并发是我们经常会遇到的，你有什么好的解决方案吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E9%81%93%E5%9C%BA%E6%99%AF%E9%A2%98%EF%BC%9A%E5%81%87%E5%A6%82%E4%BD%A0%E6%89%80%E5%9C%A8%E7%9A%84%E5%85%AC%E5%8F%B8%E9%80%89%E6%8B%A9MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%EF%BC%8C%E4%B8%80%E5%A4%A9%E4%BA%94%E4%B8%87%E6%9D%A1%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%A2%9E%E9%87%8F%EF%BC%8C%E9%A2%84%E8%AE%A1%E8%BF%90%E7%BB%B4%E4%B8%89%E5%B9%B4%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%EF%BC%9F"><span class="nav-number">39.</span> <span class="nav-text">一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">学习记录</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/17/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ai吃橘子">
      <meta itemprop="description" content="学习记录">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL | Ai吃橘子">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-17 10:43:05" itemprop="dateCreated datePublished" datetime="2023-04-17T10:43:05+08:00">2023-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-28 12:57:45" itemprop="dateModified" datetime="2023-08-28T12:57:45+08:00">2023-08-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="说一下MySQL是如何执行一条SQL的？具体步骤有哪些？"><a href="#说一下MySQL是如何执行一条SQL的？具体步骤有哪些？" class="headerlink" title="说一下MySQL是如何执行一条SQL的？具体步骤有哪些？"></a>说一下MySQL是如何执行一条SQL的？具体步骤有哪些？</h4><p><img src="http://oss.interviewguide.cn/img/202205220024265.png" alt="SQL执行的全部过程"></p>
<p>Server层按顺序执行sql的步骤为：</p>
<ol>
<li>客户端请求-&gt;</li>
<li>连接器（验证用户身份，给予权限） -&gt;</li>
<li>查询缓存（存在缓存则直接返回，不存在则执行后续操作）-&gt;</li>
<li>分析器（对SQL进行词法分析和语法分析操作） -&gt;</li>
<li>优化器（主要对执行的sql优化选择最优的执行方案方法） -&gt;</li>
<li>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-&gt;</li>
<li>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</li>
</ol>
<p>简单概括：</p>
<ul>
<li><strong>连接器</strong>：管理连接、权限验证；</li>
<li><strong>查询缓存</strong>：命中缓存则直接返回结果；</li>
<li><strong>分析器</strong>：对SQL进行词法分析、语法分析；（判断查询的SQL字段是否存在也是在这步）</li>
<li><strong>优化器</strong>：执行计划生成、选择索引；</li>
<li><strong>执行器</strong>：操作引擎、返回结果；</li>
<li><strong>存储引擎</strong>：存储数据、提供读写接口</li>
</ul>
<h4 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h4><ul>
<li><p>1NF：数据库字段不可再分（最基本要求），例如<strong>班级字段可分为专业和班号</strong>，<strong>解决方法拆字段</strong></p>
</li>
<li><p>2NF：满足1NF的情况下，在<strong>存在主键时，不能有部分依赖</strong>。(主要<strong>针对复合主键</strong>的)。例如订单号和商品号作为复合主键，商品信息只依赖商品号，<strong>解决方法是拆表</strong></p>
</li>
<li><p>3NF：满足1NF,2NF，确保数据库每个字段都和主键直接相关，而不是间接相关，例如<strong>存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</strong></p>
<p>简而言之，第三范式就是属性不依赖于其它非主属性。<strong>解决方法是拆表</strong></p>
</li>
</ul>
<p><strong>（1）简单归纳：</strong></p>
<p>第一范式（1NF）：字段不可分； 　　第二范式（2NF）：有主键，非主键字段依赖主键； 　　第三范式（3NF）：非主键字段不能相互依赖。</p>
<p><strong>（2）解释：</strong></p>
<p>1NF：原子性。 字段不可再分,否则就不是关系数据库;； 　　2NF：唯一性 。一个表只说明一个事物； 　　3NF：每列都与主键有直接关系，不存在传递依赖。</p>
<h4 id="drop、delete、和truncate区别？"><a href="#drop、delete、和truncate区别？" class="headerlink" title="drop、delete、和truncate区别？"></a>drop、delete、和truncate区别？</h4><ul>
<li>用法不同<ul>
<li>drop：删除整个表，包括表结构</li>
<li>truncate：清空整个表，保留表结构</li>
<li>delete：删除表中的某一列数据，不加条件，清空整个表，保留表结构</li>
</ul>
</li>
<li>属于不同的数据库语言<ul>
<li>truncate和drop属于DDL语言，原数据不会放入rollback segment中，无法回滚</li>
<li>delete是DML语言，会将原数据放入rollback segment中，可以回滚</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</p>
<p><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</p>
<p><code>drop</code>命令会把表占用的空间全部释放掉。</p>
</blockquote>
<h4 id="设计数据集步骤"><a href="#设计数据集步骤" class="headerlink" title="设计数据集步骤"></a>设计数据集步骤</h4><ul>
<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>
<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>
<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>
<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>
<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护</li>
</ul>
<h4 id="MyISAM和InnoDB区别"><a href="#MyISAM和InnoDB区别" class="headerlink" title="MyISAM和InnoDB区别"></a>MyISAM和InnoDB区别</h4><ul>
<li><strong>锁</strong>：MyISAM只有表级锁；InnoDB支持表级锁和行级锁</li>
<li><strong>事务</strong>：MyISAM不支持事务；InnoDB支持事务，可以提交和回滚</li>
<li><strong>外键</strong>：MyISAM不支持外键；InnoDB支持外键</li>
<li><strong>安全恢复</strong>：MyISAM不支持异常崩溃后的安全回复；InnoDB支持，恢复的过程依赖于 <code>redo log</code></li>
<li><strong>索引结构</strong>：MyISAM索引使用B+树，叶子节点存放的是数据记录的地址，索引文件和数据文件是分开的；InnoDB索引使用B+树，叶子节点存放的是完整的数据记录，非聚簇索引存放的是主键的值</li>
</ul>
<h4 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h4><ul>
<li><p><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用</p>
</li>
<li><p><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的</p>
</li>
<li><p><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的</p>
</li>
<li><p><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</p>
<blockquote>
<p>实现原理：</p>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p>
<p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p>
</blockquote>
</li>
</ul>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><ul>
<li><p>脏读</p>
<p>：一个事务读取了另一个事务未提交的数据</p>
<ul>
<li>添加写锁</li>
</ul>
</li>
<li><p><strong>丢失修改</strong>：两个事务同时操作同一个数据，同时读取了数据，修改之后提交，可能有一个事务的修改操作没有生效</p>
</li>
<li><p>不可重复读</p>
<p>：在同一个事务内，多次读取同一个数据，由于其他事务对数据的修改，多次读取的数据不同</p>
<ul>
<li>给查询范围内的数据加读锁并且读取之后不会马上释放</li>
<li>其他事务无法施加写锁，无法修改数据；但是可以插入数据，导致幻读</li>
</ul>
</li>
<li><p>幻读</p>
<p>：在同一个事务内，查询同一个表中的数据，由于其他事务添加或删除数据，发现多次查询总的数据量不同</p>
<ul>
<li>间隙锁加行锁</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul>
<li><p><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更</p>
</li>
<li><p><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据</p>
</li>
<li><p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>MySQL默认隔离级别</strong></p>
</li>
<li><p><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_19.png" alt="事务隔离"></p>
</li>
</ul>
<h4 id="join的使用和原理"><a href="#join的使用和原理" class="headerlink" title="join的使用和原理"></a>join的使用和原理</h4><ul>
<li><p><code>left join</code>：保留左表的数据，左表没有的数据设置为null，外连接</p>
</li>
<li><p><code>right join</code>：保留右表的数据，右表没有的数据设置为null，外连接</p>
</li>
<li><p><code>join(inner join)</code>：取左右表数据的交集，内连接</p>
</li>
<li><p>原理：嵌套循环（Nested-Loop Join），需要区分驱动表和被驱动表，先访问驱动表，筛选出结果集</p>
<ul>
<li><p>SNLJ（Simple Nested-Loop Join）：简单嵌套循环，将驱动表中的数据一行一行读取出来进行匹配，每行数据都会出发被驱动表的整表扫描，对比数据，将结果加入结果集，不需要回表</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_25.png" alt="SNLJ"></p>
</li>
<li><p>INLJ（Index Nested-Loop join）：索引嵌套循环。和SNLJ类似，最大的区别是用来join的字段在被驱动表中建立了索引，<strong>如果是非聚簇索引需要进行回表，聚簇索引不需要回表</strong></p>
<ul>
<li>SNLJ算法被驱动表需要每次全表查询，INLJ算法使用索引查询，性能提高</li>
</ul>
</li>
<li><p>BNLJ（Block Nested-Loop Join）：块嵌套循环，没有索引的情况下一种优化，降低被驱动表的扫描次数，使用join buffer缓冲区</p>
<ul>
<li>join bufffer缓存join所需的字段，在与被驱动表进行对比时，将buffer中的所有字段和被驱动表一起对比，如果buffer足够大，只需要对被驱动表查询一次</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_26.png" alt="BNLJ"></p>
</li>
</ul>
</li>
</ul>
<h4 id="SQL语句执行流程"><a href="#SQL语句执行流程" class="headerlink" title="SQL语句执行流程"></a>SQL语句执行流程</h4><p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_29.png" alt="执行流程"></p>
<h4 id="datetime和timestamp区别"><a href="#datetime和timestamp区别" class="headerlink" title="datetime和timestamp区别"></a>datetime和timestamp区别</h4><ul>
<li>共同点：存储精度都精确到秒</li>
<li>区别：<ul>
<li>datetime日期范围1001——9999年，timestamp范围为1970——2038年</li>
<li>datetime存储时间与时区无关，timestamp和时区相关</li>
<li>datetime占8个字节，timestamp占4字节</li>
<li>datetime默认值为null,timestamp默认为当前时间</li>
</ul>
</li>
</ul>
<h4 id="varchar和char区别"><a href="#varchar和char区别" class="headerlink" title="varchar和char区别"></a>varchar和char区别</h4><ul>
<li>char定长，varchar是变长的，用一个字符表示占用长度</li>
<li>检索效率char&gt;varchar，如果确认某个字段的值，使用char，例如MD5加密后的密码</li>
</ul>
<h4 id="in和exists区别"><a href="#in和exists区别" class="headerlink" title="in和exists区别"></a>in和exists区别</h4><ul>
<li>in先执行子查询，后执行主查询，exists相反。通常<strong>in+小表，exists+大表</strong>，遵循小表驱动大表原则，减少数据库连接次数</li>
</ul>
<h3 id="高性能优化"><a href="#高性能优化" class="headerlink" title="高性能优化"></a>高性能优化</h3><h4 id="字段设计规范"><a href="#字段设计规范" class="headerlink" title="字段设计规范"></a>字段设计规范</h4><ul>
<li><strong>优先选择符合存储需要的最小数据类型</strong>：建立索引的空间越小，一页中能够存储的索引节点数量也就越多，树的高度就越低，遍历时的IO次数就越少<ul>
<li><strong>将字符串转换成数字类型存储,如:将 IP 地址转换成整形数据</strong></li>
</ul>
</li>
<li><strong>避免使用 TEXT,BLOB 数据类型</strong>：可以将BLOB或是TEXT列分离到单独的扩展表中，查询时只取出必要的列<ul>
<li>大数据类型不能适用内存临时表，必须使用磁盘临时表，MySQL要进行二次查询，很慢</li>
</ul>
</li>
<li><strong>避免使用ENUM类型</strong>：修改ENUM值需要使用ALTER语句，排序效率很低</li>
<li><strong>尽可能把所有列定义为NOT NULL</strong>：索引NULL列需要额外的空间，会占用更多的空间，进行计算和比较时，也需要特殊处理</li>
<li><strong>使用TIMESTAMP（4字节）或DATETIME（8字节）存储时间</strong>：不要使用字符串存储日期</li>
<li><strong>财务类相关金额数据必须使用decimal类型</strong>：精准浮点数</li>
</ul>
<h4 id="索引设计规范"><a href="#索引设计规范" class="headerlink" title="索引设计规范"></a>索引设计规范</h4><ul>
<li><p><strong>建议单张表的索引不超过5个</strong>：索引在增加查询效率的同时，也会降低插入和更新的效率。MySQL在进行查询操作时，会对每一个可以使用的索引进行评估，选择最优的索引进行查询，索引太多会导致计划的时间变长，降低效率</p>
</li>
<li><p>每个Innodb都必须有主键</p>
<p>：Innodb按照主键索引的顺序来组织表</p>
<ul>
<li>不使用更新频繁的列作为主键</li>
<li>不要使用UUID,MD5,HASH字符串作为主键，无法保证数据的顺序增长</li>
<li>主键建议使用自增ID值</li>
</ul>
</li>
<li><p>设置为索引的列</p>
<p>：</p>
<ul>
<li>出现在WHERE从句中的列</li>
<li>包含在ORDER BY、GROUP BY、DISTINCT中的字段</li>
<li>不要对符合前两个条件的每个列都建立索引，建立联合索引效果更好</li>
<li>多表join的关联列</li>
</ul>
</li>
<li><p>索引列的顺序</p>
<p>：</p>
<ul>
<li>区分度最高的放在联合索引的最左侧</li>
<li>字段小的索引放在联合索引的最左侧</li>
<li>使用最频繁的列放在联合索引的最左侧</li>
</ul>
</li>
<li><p>对于频繁的查询优先考虑使用覆盖索引</p>
<p>：</p>
<ul>
<li><strong>避免 Innodb 表进行索引的二次查询:</strong> 对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>
<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，顺序获取比随机获取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO</li>
</ul>
</li>
</ul>
<h4 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h4><ul>
<li><p><strong>大批量操作可能会造成严重的主从延迟</strong></p>
<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间， 而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
</li>
<li><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong>：大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
</li>
<li><p><strong>避免产生大事务操作</strong>：大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>
</li>
<li><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>
</li>
</ul>
<h3 id="索引详解"><a href="#索引详解" class="headerlink" title="索引详解"></a>索引详解</h3><h4 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h4><ul>
<li>优点：大大加快数据的检索速度；通过创建唯一性索引，可以保证数据库中每一行数据的唯一性</li>
<li>缺点：<ul>
<li>创建维护索引需要耗时，对数据进行增删改查也需要改变索引</li>
<li>索引需要物理空间存储</li>
<li>数据库数据量不大时，索引不一定有很好的效果</li>
</ul>
</li>
</ul>
<h4 id="索引底层数据结构？为什么不使用HashMap"><a href="#索引底层数据结构？为什么不使用HashMap" class="headerlink" title="索引底层数据结构？为什么不使用HashMap?"></a>索引底层数据结构？为什么不使用HashMap?</h4><ul>
<li><p><code>不使用HashMap</code>：HashMap不支持顺序和范围查询，无法很快查找某个范围类的数据</p>
</li>
<li><p>使用B+树作为索引数据结构</p>
<blockquote>
<p>使用B树或B+树作为索引结构主要是为了减少磁盘IO的次数，降低二叉平衡查找树的高度，因此B树和B+树都为<strong>多路平衡查找树</strong></p>
<ul>
<li>一个m阶的B树具有如下几个特征：<ul>
<li>根结点至少有两个子女</li>
<li>每个中间节点都包含k-1个元素和k个孩子，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m</li>
<li>每一个叶子节点都包含k-1个元素，其中 m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m</li>
<li>所有的叶子结点都位于同一层</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划</li>
<li>每个结点都有卫星数据</li>
</ul>
</li>
<li>插入操作：判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可</li>
<li>一个m阶的B+树具有如下特征：<ul>
<li>有k个子树的中间节点包含有k个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点（m&#x2F;2 &lt;&#x3D; k &lt;&#x3D;m）</li>
<li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接</li>
<li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素</li>
<li>根节点的最大（或最小）元素也就是整个B+树中最大（或最小）的元素，要一直保持</li>
<li>只有叶子节点有卫星数据</li>
</ul>
</li>
<li>B+树的优势：<ul>
<li>单一节点存储更多的元素，使得查询的IO次数更少</li>
<li>所有查询都要查找到叶子节点，查询性能稳定</li>
<li>所有叶子节点形成有序链表，便于范围查询</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>MyISAM中，B+树叶节点的data域中存放的是数据记录的地址，取出data域的值后，还需要根据相应的地址取出相应的数据记录，这被称为<code>非聚簇索引</code></p>
</li>
<li><p>InnoDB中，其数据本身就是索引文件，树的叶节点data域保存了完整的数据记录，这被称为<code>聚簇索引</code>，这个索引的key是数据表的主键，而其余的索引都是辅助索引。辅助索引的data域存的是主键的值。</p>
<ul>
<li>根据主索引查找时，可以直接取出查找的数据</li>
<li>根据辅助索引查找时，首先查询到主键的值，再走主索引取出相应的值</li>
</ul>
</li>
</ul>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><ul>
<li><p><strong>主键索引</strong>：主键列使用的索引。InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键</p>
</li>
<li><p>二级索引（辅助索引）</p>
<p>：</p>
<ul>
<li>唯一索引：唯一索引的属性列<strong>不能出现重复的数据</strong>，允许数据为NULL，一张表可以创建多个唯一索引。一般是为了数据的唯一性，而不是为了查询效率</li>
<li>普通索引：为了快速查询数据，可以创建多个普通索引，允许数据重复和NULL</li>
<li>前缀索引：只适用于字符串数据，对文本的前几个字符创建的索引，相比普通索引建立的数据更小，<strong>会导致覆盖索引优化失效</strong></li>
<li>全文索引：为了检索大文本数据中的关键字信息</li>
</ul>
</li>
</ul>
<h4 id="唯一索引和普通索引"><a href="#唯一索引和普通索引" class="headerlink" title="唯一索引和普通索引"></a>唯一索引和普通索引</h4><ul>
<li><p>二者查询性能差不多。主要区别在于更新的记录目标页不在内存中时，<strong>普通索引</strong>更新会使用change Buffer。<strong>唯一索引</strong>，由于需要校验数据的唯一性，因此每次更新操作都需要读磁盘把数据载进内存，涉及IO操作</p>
<ul>
<li>在不影响数据一致性的前提下， InnoDB会将这些更新操作缓存在change buffer中， 这样就不需要从磁盘中读入这个数据页了。 在下次查询需要访问这个数据页的时候， 将数据页读入内存， 然后执行change buffer中与这个页有关的操作。 通过这种方式就能保证这个数据逻辑的正确性</li>
<li>change buffer中的操作应用到原数据页，得到最新结果的过程称为merge<ol>
<li>访问这个数据页会触发merge。</li>
<li>系统有后台线程会定期merge。</li>
<li>在数据库正常关闭（shutdown） 的过程中，也会执行merge操作</li>
</ol>
</li>
</ul>
<blockquote>
<p>change Buffer与redo log 区别</p>
<ul>
<li>change Buffer主要用于减少读磁盘的次数，在必要读磁盘时再更新数据。</li>
<li>redo log 则是减少内存更新后，写磁盘的次数</li>
</ul>
<p>merge的执行流程是这样的：</p>
<ol>
<li>从磁盘读入数据页到内存（老版本的数据页）；</li>
<li>从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；</li>
<li>写redo log。这个redo log包含了数据的变更和change buffer的变更</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h4><ul>
<li><p>聚集索引</p>
<p>：索引结构和数据一起存放的索引。主键索引属于聚集索引，物理地址连续</p>
<ul>
<li>优点：查询速度快，不需要进行二次查询</li>
<li>缺点：<ul>
<li>依赖于有序的数据：如果索引的数据不是有序的，需要在插入时排序</li>
<li>更新代价大：被索引的列进行修改时，对应的索引也要修改，而叶子节点也包含着数据，也要更新，代价比较大。所以对于主键索引来说，一般不可被修改</li>
</ul>
</li>
</ul>
</li>
<li><p>非聚集索引</p>
<p>：索引结构和数据分开存放的索引。二级索引属于非聚集索引，逻辑上连续，物理地址不连续</p>
<ul>
<li>优点：更新代价比聚集索引小</li>
<li>缺点：<ul>
<li>依赖于有序的数据</li>
<li>可能会产生二次查询</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>非聚集索引不一定回表查询：查询的字段刚好建立了索引，直接返回就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM table WHERE name=&#x27;guang19&#x27;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><ul>
<li>一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作</li>
<li>需要注意的是，<strong>通过二级索引查询时，回表不是必须的过程</strong>，当<strong>SELECT的所有字段在单个二级索引中都能够找到</strong>时，就不需要回表，MySQL称此时的二级索引为<strong>覆盖索引</strong>或触发了<strong>索引覆盖</strong>。 可以用Explain命令查看SQL语句的执行计划，执行计划的Extra字段中若出现<strong>Using index</strong>，表示查询触发了<strong>索引覆盖</strong>。</li>
</ul>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul>
<li>where语句中包含or时，可能会导致索引失效<ul>
<li>若or的条件中包含非索引，就会只用全表扫描的。如果or的条件两边都是索引，那么会使用<code>index_merge</code>的优化技术</li>
<li>index_merge：<strong>对多个索引分别进行条件扫描，然后将它们各自的结果进行合并</strong></li>
</ul>
</li>
<li>where语句中索引列使用了负向查询，可能会导致索引失效<ul>
<li>负向查询包括：NOT、!&#x3D;、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等</li>
</ul>
</li>
<li>对索引列进行<strong>运算</strong>，一定会导致索引失效</li>
<li>在索引列上使用<strong>内置函数</strong>，一定会导致索引失效</li>
<li>like通配符可能会导致索引失效，未满足最左匹配原则。</li>
<li>隐式类型转换导致的索引失效，如索引列user_id为varchar类型，使用int做条件关联。或者关联表字符集编码不一致。</li>
<li>索引字段可以为null，使用is null或is not null时，可能会导致索引失效</li>
<li>联合索引未满足最左匹配原则</li>
</ul>
<h4 id="建立索引的注意事项"><a href="#建立索引的注意事项" class="headerlink" title="建立索引的注意事项"></a>建立索引的注意事项</h4><ul>
<li><strong>选择合适的字段创建索引：</strong><ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
</li>
<li><strong>被频繁更新的字段应该慎重建立索引</strong>：虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</li>
<li><strong>尽可能的考虑建立联合索引而不是单列索引</strong>：因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</li>
<li><strong>注意避免冗余索引</strong>：冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</li>
<li><strong>考虑在字符串类型的字段上使用前缀索引代替普通索引</strong>：前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引</li>
</ul>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><ul>
<li>最左匹配原则：查询条件中必须要有联合索引的第一个字段才可以使用索引</li>
<li>索引覆盖：不满足最左匹配原则的情况下，如果查询的字段都在联合索引中，也可以使用到索引，并且不需要回表操作</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h4><ul>
<li><p>InnoDB独有，在系统崩溃时可以通过<code>redo log</code>恢复数据</p>
</li>
<li><p>MySQL中，查询记录是会一次将一页的信息都查询出来，加载到<code>Buffer Pool</code>中，后续查询都在<code>Buffer Pool</code>中进行，减少IO开销，更新数据也会在<code>Buffer Pool</code>中更新。然后会把在这个数据页上所做的修改，记录到<code>redo log buffer</code>中，接着刷盘到<code>redo log</code>文件中</p>
<blockquote>
<p>理想情况下，事务一提交就会进行刷盘，但实际情况下，刷盘的实际是根据策略来进行的</p>
<p>每条redo记录由<code>表空间号+数据页号+偏移量+修改数据长度+具体修改数据</code>组成</p>
</blockquote>
</li>
<li><p><strong>刷盘时机</strong>：通过设置<code>innodb_flush_log_at_trx_commit</code>参数，支持三种策略</p>
<ul>
<li>0：每次事务提交时不进行刷盘操作，宕机或者崩溃可能会有1秒的数据损失</li>
<li>1：每次事务提交时进行刷盘操作（默认），不会有数据损失</li>
<li>2：每次事务提交时，只把redo log buffer内容写入page cache，MySQL崩溃不会有损失，宕机可能会有一秒损失</li>
<li>除此之外，InnoDB引擎有一个后台线程，每隔1秒，会把<code>redo log buffer</code>中的内容写入文件系统缓存（page cache）中，然后调用<code>fsync</code>进行刷盘。当<code>redo log buffer</code>占用空间即将达到<code>innodb_log_buffer_size</code>一半时，后台线程也会主动刷盘</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_20.png" alt="刷盘"></p>
</li>
<li><p><strong>日志文件组</strong>：硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的</p>
<ul>
<li><strong>write pos</strong> ：当前记录的位置，一边写一边后移</li>
<li><strong>checkpoint</strong> ：当前要擦除的位置，也是往后推移</li>
<li>每次刷盘写入日志时，write pos会后移；每次MySQL加载日志文件组恢复数据时，会清空加载过的<code>redo log</code>，checkpoint会后移</li>
</ul>
</li>
</ul>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><ul>
<li><p>binlog是逻辑日志，记录内容是语句的原始逻辑，属于<code>MySQL Server</code>层。不管使用什么引擎，只要发生表更新，都会产生binlog。<strong>主要用于主从复制和数据恢复</strong></p>
</li>
<li><p><strong>三种格式</strong>：</p>
<ul>
<li>statement：记录SQL语句原文</li>
<li>row：记录SQL原句和操作的具体数据，比较占用空间</li>
<li>mixed：statement和row的混合，如果SQL语句会引起数据不一致，使用row；否则，使用statement</li>
</ul>
</li>
<li><p><strong>写入时机</strong>：事务执行过程中，先将日志写到binlog cache，事务提交时，再将binlog cache写入binlog文件中。</p>
<ul>
<li><p>一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code></p>
</li>
<li><p>设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync_binlog</span><br></pre></td></tr></table></figure>

<p>控制刷盘时机：</p>
<ul>
<li>0：每次提交事务只write，系统自行判断执行fsync</li>
<li>1：每次提交事务都fsync</li>
<li>N：累计N个事务再执行fsync</li>
</ul>
</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_21.png" alt="binlog"></p>
</li>
</ul>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><ul>
<li><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力；<code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性，但二者的写入时机不同</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_22.png" alt="写入时机"></p>
</li>
<li><p>为了防止binlog和redo log数据不一致，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>两个阶段</p>
<ul>
<li>在使用<code>redo log</code>恢复数据时，如果发现redo log还处于 prepare阶段，并且没有对应的binlog，就会回滚该事务</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_23.png" alt="两阶段提交"></p>
</li>
</ul>
<h4 id="undo-log-回滚日志"><a href="#undo-log-回滚日志" class="headerlink" title="undo log(回滚日志)"></a>undo log(回滚日志)</h4><ul>
<li>保证事务的原子性，所有事务的修改都会先记录到undo log中，在执行相关操作。回滚日志会优先于数据持久化到磁盘上，宕机也可以回滚</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="InnoDB对MVCC的实现"><a href="#InnoDB对MVCC的实现" class="headerlink" title="InnoDB对MVCC的实现"></a>InnoDB对MVCC的实现</h4><ul>
<li><p>通过隐藏字段、Read View和undo log实现MVCC</p>
<ul>
<li>隐藏字段：每行数据有三个隐藏字段<ul>
<li><code>DB_TRX_ID</code>：最后一次插入或者更新该行的事务id</li>
<li><code>DB_ROLL_PTR</code>：回滚指针，指向改行的undo log</li>
<li><code>DB_ROW_ID</code>：没有主键且没有唯一非空索引的情况下，<code>InnoDB</code>会使用该id生成聚簇索引</li>
</ul>
</li>
<li>ReadView：主要用来做可见性判断，保存了当前对本事务不可见的其他活跃事务<ul>
<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>
<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>
<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>
</ul>
</li>
<li>undo log：若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li>
</ul>
</li>
<li><p>数据可见性算法</p>
<p>：本次事务中读取某一行的数据</p>
<ul>
<li>如果<code>DB_TRX_ID</code>&lt;<code>m_up_limit_id</code>，则可见</li>
<li>如果<code>DB_TRX_ID</code>&gt;&#x3D;<code>m_low_limit_id</code>，表明事务快照之后才出现这一行数据，不可见</li>
<li><code>m_ids</code>为空，表示当前事务是最新的事务，可见</li>
<li>如果<code>m_up_limit_id</code>&lt;&#x3D;<code>DB_TRX_ID</code>&lt;<code>m_low_limit_id</code>，若该事务id存在m_ids中，则不可见，否则可见</li>
<li>如果事务不可见，可以通过<code>DB_ROLL_PTR</code>指针，查询该行的历史数据是否可见</li>
</ul>
</li>
</ul>
<h4 id="RC和RR隔离级别下MVCC的ReadView生成时机不同"><a href="#RC和RR隔离级别下MVCC的ReadView生成时机不同" class="headerlink" title="RC和RR隔离级别下MVCC的ReadView生成时机不同"></a>RC和RR隔离级别下MVCC的ReadView生成时机不同</h4><ul>
<li>RC下，每次查询前都要生成一个ReadView</li>
<li>RR下，只有第一次查询生成一个ReadView</li>
</ul>
<h4 id="MVCC-Next-key-Lock防止幻读（RR隔离级别）"><a href="#MVCC-Next-key-Lock防止幻读（RR隔离级别）" class="headerlink" title="MVCC+Next-key-Lock防止幻读（RR隔离级别）"></a>MVCC+Next-key-Lock防止幻读（RR隔离级别）</h4><ul>
<li>执行普通的select语句：为快照读，只在第一次查询时生成ReadView，后续事务提交不影响，可以解决幻读</li>
<li>执行select…for update&#x2F;lock in share mode、insert、update、delete等语句：为锁定读，读取的是最新的数据。InnoDB使用Next-key-Lock锁定读取到的记录以及它们之间的间隙，防止其他事务在查询范围内插入数据，防止了幻读</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_24.png" alt="SQL语句执行流程"></p>
<blockquote>
<ul>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</li>
<li>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</li>
</ul>
</blockquote>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><ul>
<li><p>全局锁：对整个数据库实例加锁，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock (FTWRL)</span><br></pre></td></tr></table></figure>

<ul>
<li>应用场景：全库逻辑备份</li>
</ul>
</li>
<li><p>表锁：分为表锁和元数据锁</p>
<ul>
<li><p>表锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock tables t1 read,t2 write</span><br></pre></td></tr></table></figure>

<ul>
<li>对其他线程来说，t1表，可以读，不可以写；t2表，读写都不可以</li>
<li>对本线程来说，t1表只能读，t2表只能读写</li>
</ul>
</li>
<li><p>元数据锁：Metadata Lock(MDL)，面向DML和DDL之间得并发控制，元数据锁不需要我们显式的加，系统默认会加</p>
<ul>
<li>当做DML操作时，会申请一个MDL读锁</li>
<li>当做DDL操作时，会申请一个MDL写锁</li>
<li>读锁之间不互斥，读写和写写之间都互斥</li>
</ul>
</li>
</ul>
</li>
<li><p>行锁：InnoDB的行锁是针对索引加的，而不是针对记录，该索引不能失效，否则会升级为表锁</p>
<ul>
<li><code>select * from t lock in share mode</code></li>
</ul>
</li>
</ul>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><ul>
<li><p>在InnoDB事务中， 行锁是在需要的时候才加上的， 但并不是不需要了就立刻释放， 而是要等到事务结束时才释放</p>
<ul>
<li>事务B要在事务A提交之后才会执行</li>
</ul>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_30.png" alt="示例"></p>
</li>
<li><p>出现死锁：</p>
<ul>
<li>进入等待，超时</li>
<li>发起死锁检测，回滚死锁链中的某一个事务，打破死锁</li>
</ul>
</li>
</ul>
<h4 id="加锁原则"><a href="#加锁原则" class="headerlink" title="加锁原则"></a>加锁原则</h4><ul>
<li>原则1： 加锁的基本单位是next-keylock，前开后闭区间</li>
<li>原则2： 查找过程中访问到的对象才会加锁</li>
<li>优化1： 索引上的等值查询， 给唯一索引加锁的时候， next-keylock退化为行锁</li>
<li>优化2： 索引上的等值查询， 向右遍历时且最后一个值不满足等值条件的时候， next-key lock退化为间隙锁。</li>
<li>一个bug： 唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<h3 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h3><h4 id="超大分页如何处理？"><a href="#超大分页如何处理？" class="headerlink" title="超大分页如何处理？"></a>超大分页如何处理？</h4><ul>
<li>使用主键id优化，找到上次分页的最大ID，利用主键索引进行查询。<strong>要求ID必须是连续的</strong></li>
<li>覆盖索引优化，先查出索引的主键ID，再使用主键索引拿数据</li>
</ul>
<h4 id="优化SQL？"><a href="#优化SQL？" class="headerlink" title="优化SQL？"></a>优化SQL？</h4><ul>
<li>添加合适索引：索引创建原则</li>
<li>优化表结构：数据类型越小越好、尽量少使用NULL</li>
<li>优化查询语句：是否命中索引等</li>
</ul>
<h4 id="分布式主键方案？"><a href="#分布式主键方案？" class="headerlink" title="分布式主键方案？"></a>分布式主键方案？</h4><ul>
<li>数据库自增序列</li>
<li>UUID</li>
<li>Redis生成ID</li>
<li>等</li>
</ul>
<h4 id="分库分表？"><a href="#分库分表？" class="headerlink" title="分库分表？"></a>分库分表？</h4><ul>
<li><p>分表：单表数据量过大，会影响查询性能。将一个表的数据放在多个表中</p>
<ul>
<li><p>垂直分表：把一个表的多个字段拆分为多个表，一般将字段作冷热拆分，冷字段一个表，热字段一个表</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_31.png" alt="垂直分表案例"></p>
</li>
<li><p>水平分表：减少单个表中的数据量</p>
</li>
</ul>
</li>
<li><p>分库：单库的并发量最多到2000，将一个库的数据拆分到多个库中，可以增加并发量</p>
<ul>
<li><p>垂直分库：将关联度低的表存放在不同的库中</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_32.png" alt="垂直分库案例"></p>
</li>
<li><p>水平分库：提升单个业务系统的QPS</p>
<p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_33.png" alt="水平分库案例"></p>
</li>
</ul>
</li>
<li><p>垂直切分的优缺点：</p>
<ul>
<li>优点：切合业务系统结构；方便对数据进行管理；提升系统的高并发性能</li>
<li>缺点：没有解决单表数据量过大的问题；分布式事务处理复杂</li>
</ul>
</li>
<li><p>水平切分的优缺点：</p>
<ul>
<li>优点：提升系统性能，不存在性能瓶颈；对业务没有影响</li>
<li>缺点：数据多次扩展难度和维护大</li>
</ul>
</li>
</ul>
<h4 id="大表查询优化"><a href="#大表查询优化" class="headerlink" title="大表查询优化"></a>大表查询优化</h4><ul>
<li>优化sql语句，增加索引</li>
<li>增加缓存，使用redis</li>
<li>主从复制，读写分离</li>
<li>分库分表</li>
</ul>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p><img src="https://hehemagic.github.io/2022/01/03/day29/day29_34.png" alt="主从复制过程"></p>
<ul>
<li><ol>
<li>Master的更新事件(update、insert、delete)会按照顺序写入bin-log中。当Slave连接到Master的后,Master机器会为Slave开启 binlog dump线程,该线程会去读取bin-log日志</li>
<li>Slave连接到Master后,Slave库有一个I&#x2F;O线程 通过请求binlog dump thread读取bin-log日志,然后写入从库的relay log日志中。</li>
<li>Slave还有一个 SQL线程,实时监控 relay-log日志内容是否有更新,解析文件中的SQL语句,在Slave数据库中去执行。</li>
</ol>
</li>
</ul>
<h4 id="主从复制同步方式"><a href="#主从复制同步方式" class="headerlink" title="主从复制同步方式"></a>主从复制同步方式</h4><ul>
<li><strong>异步复制</strong> ：Mysql主从同步 默认是异步复制的。就是上面三步中,只有第一步是同步的(也就是Mater写入bin log日志),就是主库写入binlog日志后即可成功返回客户端，无须等待binlog日志传递给从库的过程。 Master 不关心 Slave 的数据有没有写入成功。因此如果Master和Slave之间有网络延迟，就会造成暂时的数据不一致的现象；如果Master出故障，而数据还没有复制过去，则会造成数据丢失；但也有好处，<strong>效率较其他两种复制方式最高</strong>。</li>
<li><strong>同步复制</strong> ：Master主机将事件发送给Slave主机后会触发一个等待，直到所有Slave节点（如果有多个Slave）返回数据复制成功的信息给Master。 这种复制方式最安全，但是同时，效率也是最差的。</li>
<li><strong>半同步复制</strong> ：对于半同步复制而言，Master主机将事件发送给Slave主机后会触发一个等待，直到其中一个Slave节点（如果有多个Slave）返回数据复制成功的信息给Master。 由此增强了数据的一致性，但是因为Master主机的确认开销，会损耗一部分的性能； 另外，半同步复制除了不需要等待所有Slave主机确认事件的接收外，半同步数据复制并不要求那些事件完全地执行，因此，仍有可能看到在Slave主机上数据复制延迟的发生，如果因为网络延迟等原因造成Slave迟迟没有返回复制成功的信息，超过了Master设置的超时时长，<strong>半同步复制就降级为异步复制方式</strong>，而后继续数据复制。</li>
</ul>
<h4 id="Mysql主从同步延时产生原因-怎么优化？"><a href="#Mysql主从同步延时产生原因-怎么优化？" class="headerlink" title="Mysql主从同步延时产生原因?怎么优化？"></a>Mysql主从同步延时产生原因?怎么优化？</h4><ul>
<li>原因：<ul>
<li>主节点如果执行一个很大的事务，会对主从延迟产生较大的影响</li>
<li>网络延迟，日志较大，slave数量过多</li>
<li>机器性能问题，从节点是否使用了“烂机器”</li>
</ul>
</li>
<li>优化：<ul>
<li>大事务：将大事务分为小事务，分批更新数据</li>
<li>减少Slave的数量，不要超过5个，减少单次事务的大小</li>
</ul>
</li>
</ul>
<h2 id="你了解MySQL的内部构造吗？一般可以分为哪两个部分？"><a href="#你了解MySQL的内部构造吗？一般可以分为哪两个部分？" class="headerlink" title="你了解MySQL的内部构造吗？一般可以分为哪两个部分？"></a>你了解MySQL的内部构造吗？一般可以分为哪两个部分？</h2><p>可以分为服务层和存储引擎层两部分，其中：</p>
<p><strong>服务层包括连接器、查询缓存、分析器、优化器、执行器等</strong>，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p><strong>存储引擎层负责数据的存储和提取</strong>。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。</p>
<h2 id="都知道数据库索引采用B-树而不是B树，原因也有很多，主要原因是什么？"><a href="#都知道数据库索引采用B-树而不是B树，原因也有很多，主要原因是什么？" class="headerlink" title="都知道数据库索引采用B+树而不是B树，原因也有很多，主要原因是什么？"></a>都知道数据库索引采用B+树而不是B树，原因也有很多，主要原因是什么？</h2><p>主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且叶子节点关于主键是顺序分布的，方便范围查找，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低</p>
<p>B+树查找效率更加稳定（所有数据都在叶子节点），B树有可能在中间节点找到数据（有的数据在叶子节点，有的在根节点或根节点附近），导致读取数据的稳定性不高，有的数据返回的快，有的数据返回的慢，不利于程序员做性能规划</p>
<p>B+tree的磁盘读写代价更低：B+tree的内部结点只存储索引值关键字信息，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，树的高度就低，相对来说IO读写次数也就降低了；</p>
<p>B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；</p>
<h2 id="为什么MySQL索引要使用B-树，而不是B树或者红黑树？"><a href="#为什么MySQL索引要使用B-树，而不是B树或者红黑树？" class="headerlink" title="为什么MySQL索引要使用B+树，而不是B树或者红黑树？"></a>为什么MySQL索引要使用B+树，而不是B树或者红黑树？</h2><p>我们在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。</p>
<p>为什么B类树可以进行优化呢？我们可以根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息，<strong>保证层数（树的高度）尽量的少</strong>，以便后面我们可以更快的找到信息，<strong>磁盘的I&#x2F;O操作也少一些</strong>，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。</p>
<h2 id="既然Hash比B-树更快，为什么MySQL用B-树来存储索引呢？"><a href="#既然Hash比B-树更快，为什么MySQL用B-树来存储索引呢？" class="headerlink" title="既然Hash比B+树更快，为什么MySQL用B+树来存储索引呢？"></a>既然Hash比B+树更快，为什么MySQL用B+树来存储索引呢？</h2><p>MySQL中存储索引用到的数据结构是B+树，B+树的查询时间跟树的高度有关，是log(n)，如果用hash存储，那么查询时间是O(1)。</p>
<p>采用Hash来存储确实要更快，但是采用B+树来存储索引的原因主要有以下两点：</p>
<p>一、<strong>从内存角度上说</strong>，数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载。</p>
<p>二、<strong>从业务场景上说</strong>，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash（hash只适合等值查询，对范围查询效果很差）就快很多了。</p>
<h2 id="关系型和非关系型数据库的区别你了解多少？"><a href="#关系型和非关系型数据库的区别你了解多少？" class="headerlink" title="关系型和非关系型数据库的区别你了解多少？"></a>关系型和非关系型数据库的区别你了解多少？</h2><ul>
<li>关系型数据库（例如MySQL）的优点<ul>
<li>容易理解。因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带where子句的查询）</li>
</ul>
</li>
<li>非关系型数据库（例如redis）的优点<ul>
<li>不需要经过SQL层的解析，读写效率高。</li>
<li>基于键值对，数据的扩展性很好。</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。</li>
</ul>
</li>
</ul>
<h2 id="什么是非关系型数据库？"><a href="#什么是非关系型数据库？" class="headerlink" title="什么是非关系型数据库？"></a>什么是非关系型数据库？</h2><p>非关系型数据库也叫NOSQL，采用键值对的形式进行存储。</p>
<p>它的读写性能很高，易于扩展，可分为内存性数据库以及文档型数据库，比如 Redis，Mongodb，HBase等等。</p>
<p>适合使用非关系型数据库的场景：</p>
<ul>
<li>日志系统</li>
<li>地理位置存储</li>
<li>数据量巨大</li>
<li>高可用</li>
</ul>
<h2 id="数据库引擎InnoDB与MyISAM的区别"><a href="#数据库引擎InnoDB与MyISAM的区别" class="headerlink" title="数据库引擎InnoDB与MyISAM的区别"></a>数据库引擎InnoDB与MyISAM的区别</h2><p><strong>InnoDB</strong></p>
<ul>
<li>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</li>
<li>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻读。</li>
<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</li>
<li>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</li>
<li>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</li>
</ul>
<p><strong>MyISAM</strong></p>
<ul>
<li>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</li>
<li>提供了大量的特性，包括压缩表、空间数据索引等。</li>
<li>不支持事务。</li>
<li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>事务: InnoDB 是事务型的，可以使用 <code>Commit</code> 和 <code>Rollback</code> 语句。MyISAM不支持事务</li>
<li>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>
<li>外键: InnoDB 支持外键。</li>
<li>备份: InnoDB 支持在线热备份。</li>
<li>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>
<li>其它特性: MyISAM 支持压缩表和空间数据索引。</li>
<li>MyISAM采用非聚集索引，B+树叶子存储指向数据文件的指针。InnoDB主键索引采用聚集索引，B+树叶子存储数据</li>
</ul>
<p><strong>适用场景</strong>： </p>
<p>MyISAM适合： 插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择， 没有事务。</p>
<p> InnoDB适合： 可靠性要求比较高，或者要求事务； 表更新和查询都相当的频繁， 大量的INSERT或UPDATE</p>
<h2 id="MyISAM和InnoDB实现B-树索引方式的区别是什么？"><a href="#MyISAM和InnoDB实现B-树索引方式的区别是什么？" class="headerlink" title="MyISAM和InnoDB实现B+树索引方式的区别是什么？"></a>MyISAM和InnoDB实现B+树索引方式的区别是什么？</h2><ul>
<li><p><strong>MyISAM，B+Tree叶节点的data域存放的是数据记录的地址</strong>，<strong>以MyISAM为存储引擎的表不存在聚簇索引。</strong>在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”</p>
</li>
<li><p>InnoDB，其数据文件本身就是索引文件，相比MyISAM（索引文件和数据文件是分离的），其表数据文件本身就是按B+Tree组织的一个索引结构，<strong>树的节点data域保存了完整的数据记录</strong>，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。</p>
<p>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引（二级索引）查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
</li>
</ul>
<h2 id="InnoDB为什么要用自增id作为主键？"><a href="#InnoDB为什么要用自增id作为主键？" class="headerlink" title="InnoDB为什么要用自增id作为主键？"></a>InnoDB为什么要用自增id作为主键？</h2><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面。</p>
<h2 id="MySQL中为什么要有事务回滚机制？"><a href="#MySQL中为什么要有事务回滚机制？" class="headerlink" title="MySQL中为什么要有事务回滚机制？"></a>MySQL中为什么要有事务回滚机制？</h2><p>而在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再对数据库中的对应磁盘位置行进行写入。 当事务已经被提交之后，就无法再次回滚了。</p>
<p>回滚日志作用：</p>
<p>   1.能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息 </p>
<ol start="2">
<li>在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。</li>
</ol>
<h2 id="数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？"><a href="#数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？" class="headerlink" title="数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？"></a>数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗？</h2><p>分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能、可用性和扩展性，缩短查询时间。</p>
<p><strong>数据库为什么要进行分库和分表呢？</strong></p>
<ol>
<li><strong>提高性能</strong>：随着数据量的增加，单一数据库或表可能会面临性能瓶颈。通过分库分表，可以将数据分布到不同的节点和表中，从而实现更好的并发访问和查询性能。</li>
<li><strong>可扩展性</strong>：随着业务的扩展，数据库的负载也会增加。分库分表可以在水平方向上进行扩展，通过增加数据库节点和表的数量，从而满足不断增长的数据需求。</li>
<li><strong>减少单点故障</strong>：将数据分布到多个节点和表中可以减少单点故障的风险。如果一个节点或表发生故障，其他节点或表仍然可以正常工作，从而保障系统的可用性。</li>
<li><strong>灵活管理和维护</strong>：分库分表使得数据库的管理和维护更加灵活。可以根据实际需求对不同的库和表执行备份、优化、恢复等操作，而不会影响整个系统。</li>
<li><strong>满足不同数据特点</strong>：不同的数据可能有不同的访问频率和访问模式。通过分表，可以针对不同的数据特点选择合适的存储引擎、分区策略等，以提高查询性能。</li>
</ol>
<p><strong>都放在一个库或者一张表中不可以吗？</strong></p>
<p>虽然将所有数据放在一个库或一张表中是可能的，但是在大规模应用中，这种设计方式会面临以下问题：</p>
<ol>
<li><strong>性能瓶颈</strong>：随着数据量的增加，单一库或表的性能可能会变得不足，导致查询效率下降。</li>
<li><strong>可扩展性受限</strong>：单一库或表的扩展有限，可能会限制系统的水平扩展能力。</li>
<li><strong>单点故障风险</strong>：如果单一库或表发生故障，整个系统的数据都可能受到影响。</li>
<li><strong>维护复杂性</strong>：在单一库或表中进行维护和备份可能变得复杂，同时也会影响维护的灵活性。</li>
<li><strong>查询效率下降</strong>：如果单一表包含大量数据，查询性能可能会下降，因为查询需要遍历大量数据。</li>
</ol>
<h2 id="数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于拆分数据表你了解哪些？"><a href="#数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于拆分数据表你了解哪些？" class="headerlink" title="数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于拆分数据表你了解哪些？"></a>数据库优化中有一个比较常用的手段就是把数据表进行拆分，关于拆分数据表你了解哪些？</h2><p><strong>水平拆分</strong>： 水平拆分主要解决的问题是数据表的规模过大，导致查询性能下降和扩展性受限的情况。通过将大的数据表按照某种规则拆分成多个子表，可以达到以下目的：</p>
<ol>
<li><strong>提高查询性能</strong>：拆分后的子表数据量较小，查询时只需访问特定的子表，减少了查询数据量，从而提高了查询性能。</li>
<li><strong>分散负载</strong>：不同的子表可以分布在不同的物理节点上，从而实现负载均衡，减轻单个节点的压力。</li>
<li><strong>水平扩展</strong>：可以通过增加子表的数量来实现数据库的水平扩展，从而满足不断增长的数据需求。</li>
</ol>
<p>水平拆分是指将一个大的数据表按照一定的规则拆分成多个子表，每个子表存储一部分数据。这种方式适用于数据量大、扩展性要求高的情况。一个常见的应用场景是电子商务平台的订单表。假设有一个订单表 <code>orders</code> 包含了大量的订单记录，而每个订单又包含了多个订单项。这时可以将订单表水平拆分为多个子表，例如按照订单日期范围拆分成多个月份的子表，如 <code>orders_2023_01</code>、<code>orders_2023_02</code> 等。这样做的好处是，查询特定时间段的订单时，只需访问相应的子表，减少了查询数据量，提高了查询性能。</p>
<p><strong>垂直拆分</strong>： 垂直拆分主要解决的问题是数据表的列数过多，其中一些列关注点不同，导致查询效率下降和维护复杂的情况。通过将大的数据表按照列的属性进行拆分，可以达到以下目的：</p>
<ol>
<li><strong>提高查询效率</strong>：拆分后的子表只包含特定的列，查询时不会涉及无关的列，从而提高了查询效率。</li>
<li><strong>分离关注点</strong>：不同的子表关注不同的业务逻辑，使得数据表更加清晰、易于理解，并且可以避免在查询时涉及无关的列。</li>
<li><strong>灵活维护</strong>：对于某些表，可能只需要对其中一部分列进行维护，而不需要关注其他列。拆分后的子表使维护变得更加灵活和可控。</li>
</ol>
<p> 垂直拆分是将一个大的数据表按照列的属性进行拆分，使每个子表关注特定的业务逻辑。这种方式适用于表中包含的列过多、关注点不同的情况。一个常见的应用场景是用户信息表。假设有一个用户信息表 <code>users</code>，其中包含了用户的基本信息（如用户名、密码）和用户的个人资料（如年龄、性别）。这时可以将用户信息表垂直拆分为两个子表，一个是存储基本信息的表，另一个是存储个人资料的表。这样做的好处是，当查询只需要基本信息时，不会涉及到个人资料表，从而提高了查询效率。</p>
<p><strong>需要注意的是，拆分数据表虽然可以带来性能和扩展性的好处，但也会增加查询和维护的复杂性。在进行数据表拆分时，需要仔细考虑数据之间的关系、查询需求以及系统的架构，以确保拆分后的表仍然能够满足业务需求，并且不引入过多的复杂性。</strong></p>
<h2 id="数据库并发事务会带来哪些问题？"><a href="#数据库并发事务会带来哪些问题？" class="headerlink" title="数据库并发事务会带来哪些问题？"></a>数据库并发事务会带来哪些问题？</h2><p>数据库并发会带来脏读、幻读、丢弃更改、不可重复读这四个常见问题，其中：</p>
<p><strong>脏读</strong>：在第一个修改事务和读取事务进行的时候，读取事务读到的数据为100，这是修改之后的数据，但是之后该事务满足一致性等特性而做了回滚操作，那么读取事务得到的结果就是脏数据了。  （<strong>自己的事务读取到别的事物还没提交的数据</strong>）</p>
<p><strong>幻读</strong>：一般是T1在某个范围内进行修改操作（增加或者删除），而T2读取该范围导致读到的数据是修改之间的了，强调范围。</p>
<p><strong>丢弃修改</strong>：两个写事务T1 T2同时对A&#x3D;0进行递增操作，结果T2覆盖T1，导致最终结果是1 而不是2，事务被覆盖</p>
<p><strong>不可重复读</strong>：T2 读取一个数据，然后T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p>（<strong>自己的事务读取目标数据的过程中别的事务修改了该目标数据的值</strong>）</p>
<h2 id="不可重复读和幻读区别是什么？可以举个例子吗？"><a href="#不可重复读和幻读区别是什么？可以举个例子吗？" class="headerlink" title="不可重复读和幻读区别是什么？可以举个例子吗？"></a>不可重复读和幻读区别是什么？可以举个例子吗？</h2><p><strong>不可重复读的重点是修改，幻读的重点在于新增或者删除。</strong></p>
<ul>
<li><p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。</p>
</li>
<li><p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记 录就变为了5条，这样就导致了幻读。</p>
</li>
</ul>
<h2 id="不可重复读和脏读区别是什么？可以举个例子吗？"><a href="#不可重复读和脏读区别是什么？可以举个例子吗？" class="headerlink" title="不可重复读和脏读区别是什么？可以举个例子吗？"></a>不可重复读和脏读区别是什么？可以举个例子吗？</h2><ol>
<li><p>**不可重复读 (Non-repeatable Read)**： 不可重复读是指在一个事务内，同一个查询在不同时间点多次执行，但返回的结果不一致。这是由于在事务执行期间，其他事务可能修改了相同的数据，导致不同的查询返回不同的结果。这可能会导致数据的不一致性。</p>
<p>示例：</p>
<ul>
<li>事务 A 查询某个记录的值为 X。</li>
<li>事务 B 修改了该记录的值为 Y，并提交。</li>
<li>事务 A 再次查询同一个记录，发现其值变为了 Y，与之前的查询结果不同。</li>
</ul>
</li>
<li><p>**脏读 (Dirty Read)**： 脏读是指一个事务读取了另一个事务未提交的数据。换句话说，脏读就是读取了还未生效的数据，这可能会导致错误的信息传递和不一致性。</p>
<p>示例：</p>
<ul>
<li>事务 A 修改某个记录的值，但未提交。</li>
<li>事务 B 读取了事务 A 修改后的值，然后事务 A 回滚了，撤销了之前的修改。</li>
<li>此时事务 B 所读取的值实际上是无效的、未提交的数据，称为脏数据。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li>“不可重复读” 是指一个事务内相同查询在不同时间点返回不同结果，因为其他事务修改了相同数据。</li>
<li>“脏读” 是指一个事务读取了另一个事务未提交的数据，可能会导致读取到无效或错误的数据。</li>
</ul>
<h2 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h2><ul>
<li><strong>未提交读</strong>，事务中发生了修改，即使没有提交，其他事务也是可见的，比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100.<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>提交读</strong>，对于一个事务从开始直到提交之前，所做的任何修改是其他事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>重复读</strong>，就是对一个记录读取多次的记录是相同的，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong></li>
<li><strong>可串行化读</strong>，在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；<strong>该级别可以防止脏读、不可重复读以及幻读</strong></li>
</ul>
<p>InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别 下使用的是<strong>Next-Key Lock 锁</strong>算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以 说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要 求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。</p>
<h2 id="数据库悲观锁和乐观锁的原理和应用场景分别有什么？"><a href="#数据库悲观锁和乐观锁的原理和应用场景分别有什么？" class="headerlink" title="数据库悲观锁和乐观锁的原理和应用场景分别有什么？"></a>数据库悲观锁和乐观锁的原理和应用场景分别有什么？</h2><p>悲观锁，先获取锁，再进行业务操作，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。 当数据库执行SELECT … FOR UPDATE时会获取被select中的数据行的行锁，select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p>
<p>乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。如果版本不一样，就需要回滚，然后重新操作。</p>
<h2 id="说一说Drop、Delete与Truncate的共同点和区别"><a href="#说一说Drop、Delete与Truncate的共同点和区别" class="headerlink" title="说一说Drop、Delete与Truncate的共同点和区别"></a>说一说Drop、Delete与Truncate的共同点和区别</h2><p><strong>第一种回答</strong></p>
<p>Drop、Delete、Truncate都表示删除，但是三者有一些差别：</p>
<p><strong>Delete</strong>用来删除表的全部或者一部分数据行，执行delete之后，用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器。</p>
<p><strong>Truncate</strong>删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比delete更快，占用的空间更小。</p>
<p><strong>Drop</strong>命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。</p>
<p>因此，在不再需要一张表的时候，用Drop；在想删除部分数据行时候，用Delete；在保留表而删除所有数据的时候用Truncate。</p>
<p><strong>第二种回答</strong></p>
<ul>
<li>Drop直接删掉表，不能回滚;</li>
<li>Truncate删除表中全部数据但是不删除表，再插入时自增长id又从1开始 ，不能回滚;</li>
<li>Delete删除表中部分数据，可以加where字句，可以回滚。</li>
</ul>
<h2 id="数据库中的视图作用"><a href="#数据库中的视图作用" class="headerlink" title="数据库中的视图作用"></a>数据库中的视图作用</h2><p>数据库中的视图（View）是一个虚拟表，它是基于一个或多个表的查询结果构建而成，可以将多个表的数据组合、过滤或转换成一个逻辑上的表。视图在数据库中起到了多种重要作用：</p>
<ol>
<li><strong>数据安全性和访问控制</strong>：<ul>
<li>视图可以隐藏底层数据表的结构和部分数据，只向用户暴露需要的信息，从而增加数据的安全性。</li>
<li>可以通过视图控制用户对数据的访问权限，限制用户只能查询视图的内容，而不是直接访问表。</li>
</ul>
</li>
<li><strong>简化查询</strong>：<ul>
<li>视图可以将多个表的数据组合成一个逻辑上的表，简化了查询操作，减少了复杂的JOIN操作和子查询。</li>
<li>可以在视图中预先定义常用的查询，使用户不必重复编写相同的查询语句。</li>
</ul>
</li>
<li><strong>数据转换和格式化</strong>：<ul>
<li>视图可以对数据进行转换、计算和格式化，使得查询结果更符合用户需求。</li>
<li>可以在视图中添加计算字段、别名、格式化日期等操作，减少应用层的处理。</li>
</ul>
</li>
<li><strong>数据一致性</strong>：<ul>
<li>视图可以确保多个表之间的数据一致性，避免了冗余和不一致的数据。</li>
<li>可以将多个相关的表连接在一起，确保查询结果是一致的。</li>
</ul>
</li>
<li><strong>性能优化</strong>：<ul>
<li>视图可以预先定义复杂的查询，减轻数据库的查询压力，提高性能。</li>
<li>可以将频繁查询的操作预先计算并存储在视图中，减少查询的计算量。</li>
</ul>
</li>
</ol>
<h2 id="为什么使用索引？"><a href="#为什么使用索引？" class="headerlink" title="为什么使用索引？"></a>为什么使用索引？</h2><ul>
<li><strong>加速查询</strong>：索引可以快速定位符合条件的数据，减少了全表扫描的需要，从而提高查询速度。特别是在大型数据表中，索引可以将查询时间从线性复杂度降低为对数复杂度。</li>
<li><strong>减少IO操作</strong>：索引可以直接指导数据库引擎访问特定的数据行，减少了从磁盘读取数据的IO操作，从而提高了查询性能。</li>
<li><strong>优化排序和分组</strong>：索引可以加速排序和分组操作，提高聚合查询的效率。</li>
<li><strong>提高并发性能</strong>：索引可以减少数据行的锁定范围，提高并发性能，允许多个会话同时读取不同的数据。</li>
<li><strong>优化连接操作</strong>：在连接操作中，索引可以快速定位匹配的数据行，提高连接查询的性能。</li>
<li><strong>支持唯一性约束</strong>：唯一索引可以确保某个列的值在表中唯一，避免了重复数据的插入，保证数据的一致性。</li>
<li><strong>支持覆盖索引</strong>：如果索引包含了查询所需的所有列，数据库引擎可以直接从索引中获取数据，避免了从数据表中读取数据的开销。</li>
</ul>
<h2 id="既然索引有那么多优点，为什么不对表的每一列创建一个索引呢？"><a href="#既然索引有那么多优点，为什么不对表的每一列创建一个索引呢？" class="headerlink" title="既然索引有那么多优点，为什么不对表的每一列创建一个索引呢？"></a>既然索引有那么多优点，为什么不对表的每一列创建一个索引呢？</h2><ul>
<li>当对表中的数据进行增加、删除和修改的时候，<strong>索引也要动态的维护</strong>，这样就降低了数据的维护速度。</li>
<li><strong>索引需要占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立簇索引，那么需要的空间就会更大。</li>
<li><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加</li>
</ul>
<h2 id="MySQL索引都有哪些分类？"><a href="#MySQL索引都有哪些分类？" class="headerlink" title="MySQL索引都有哪些分类？"></a>MySQL索引都有哪些分类？</h2><p>按数据结构分类可分为：<strong>B+tree索引、Hash索引、Full-text索引</strong>。 </p>
<p>按物理存储分类可分为：<strong>聚簇索引、二级索引（辅助索引）</strong>。 </p>
<p>按字段特性分类可分为：<strong>主键索引、普通索引、前缀索引</strong>。 </p>
<p>按字段个数分类可分为：<strong>单列索引、联合索引（复合索引、组合索引）</strong></p>
<p>由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“&#x3D;”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。</p>
<ul>
<li><strong>普通索引</strong>：仅加速查询</li>
<li><strong>唯一索引</strong>：加速查询 + 列值唯一（可以有null）</li>
<li><strong>主键索引</strong>：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li>
<li><strong>组合索引</strong>：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li>
<li><strong>全文索引</strong>：对文本的内容进行分词，进行搜索</li>
<li><strong>索引合并</strong>：使用多个单列索引组合搜索</li>
<li><strong>覆盖索引</strong>：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</li>
<li><strong>聚簇索引</strong>：表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)</li>
</ul>
<h2 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h2><p>使用非空字段：应该指定列为NOT NULL，除非你想存储NULL。在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</p>
<p>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</p>
<p>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。 唯一、不为空、经常被查询的字段 的字段适合建索引</p>
<h2 id="MySQL-索引使用的注意事项"><a href="#MySQL-索引使用的注意事项" class="headerlink" title="MySQL 索引使用的注意事项"></a>MySQL 索引使用的注意事项</h2><p><strong>1）不要在列上使用函数或进行计算，这都将导致索引失效而进行全表扫描。</strong></p>
<p><strong>2）尽量避免使用 !&#x3D; 或 not in或 &lt;&gt; 等否定操作符，因为这几个操作符都会导致索引失效而进行全表扫描。</strong></p>
<h2 id="数据库中的主键、超键、候选键、外键是什么？"><a href="#数据库中的主键、超键、候选键、外键是什么？" class="headerlink" title="数据库中的主键、超键、候选键、外键是什么？"></a>数据库中的主键、超键、候选键、外键是什么？</h2><ul>
<li><strong>超键</strong>：在关系中能唯一标识<strong>元组的属性集</strong>称为关系模式的超键</li>
<li><strong>候选键</strong>：不含有<strong>多余属性的超键</strong>称为候选键。也就是在候选键中，若再删除属性，就不是键了！</li>
<li><strong>主键</strong>：<strong>用户选作元组标识的一个候选键程序主键</strong></li>
<li><strong>外键</strong>：如果关系模式<strong>R中属性K是其它模式的主键</strong>，那么<strong>k在模式R中称为外键</strong>。</li>
</ul>
<p><strong>举例</strong>：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>性别</th>
<th>年龄</th>
<th>系别</th>
<th>专业</th>
</tr>
</thead>
<tbody><tr>
<td>20020612</td>
<td>李辉</td>
<td>男</td>
<td>20</td>
<td>计算机</td>
<td>软件开发</td>
</tr>
<tr>
<td>20060613</td>
<td>张明</td>
<td>男</td>
<td>18</td>
<td>计算机</td>
<td>软件开发</td>
</tr>
<tr>
<td>20060614</td>
<td>王小玉</td>
<td>女</td>
<td>19</td>
<td>物理</td>
<td>力学</td>
</tr>
<tr>
<td>20060615</td>
<td>李淑华</td>
<td>女</td>
<td>17</td>
<td>生物</td>
<td>动物学</td>
</tr>
<tr>
<td>20060616</td>
<td>赵静</td>
<td>男</td>
<td>21</td>
<td>化学</td>
<td>食品化学</td>
</tr>
<tr>
<td>20060617</td>
<td>赵静</td>
<td>女</td>
<td>20</td>
<td>生物</td>
<td>植物学</td>
</tr>
</tbody></table>
<ol>
<li>超键：于是我们从例子中可以发现 学号是标识学生实体的唯一标识。那么该元组的超键就为学号。除此之外我们还可以把它跟其他属性组合起来，比如：(<code>学号</code>，<code>性别</code>)，(<code>学号</code>，<code>年龄</code>)</li>
<li>候选键：根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际上，候选键是超键的子集，比如 （学号，年龄）是超键，但是它不是候选键。因为它还有了额外的属性。</li>
<li>主键：简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号就为主键。</li>
<li>外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成绩单表的外键，为学生表的主键。</li>
</ol>
<p><strong>主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。</strong></p>
<h2 id="事务四大特性（ACID）原子性、一致性、隔离性、持久性？"><a href="#事务四大特性（ACID）原子性、一致性、隔离性、持久性？" class="headerlink" title="事务四大特性（ACID）原子性、一致性、隔离性、持久性？"></a>事务四大特性（ACID）原子性、一致性、隔离性、持久性？</h2><p><strong>第一种回答</strong></p>
<p><strong>原子性</strong>：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。 。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p><strong>一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
<p><strong>隔离性</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p><strong>持久性</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<p><strong>第二种回答</strong></p>
<p>原子性（Atomicity）</p>
<ul>
<li>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
</ul>
<p>一致性（Consistency）</p>
<ul>
<li>事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</li>
</ul>
<p>隔离性（Isolation）</p>
<ul>
<li>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
</ul>
<p>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。   持久性（Durability）</p>
<ul>
<li>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
<h2 id="数据库如何保证一致性？"><a href="#数据库如何保证一致性？" class="headerlink" title="数据库如何保证一致性？"></a>数据库如何保证一致性？</h2><p>分为两个层面来说。</p>
<ul>
<li><strong>从数据库层面</strong>，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。<strong>数据库必须要实现AID三大特性，才有可能实现一致性</strong>。例如，原子性无法保证，显然一致性也无法保证。</li>
<li><strong>从应用层面</strong>，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！</li>
</ul>
<h2 id="数据库如何保证原子性？"><a href="#数据库如何保证原子性？" class="headerlink" title="数据库如何保证原子性？"></a>数据库如何保证原子性？</h2><p>主要是利用 Innodb 的<strong>undo log</strong>。 <strong>undo log</strong>名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 SQL语句，他需要记录你要回滚的相应日志信息。 例如</p>
<ul>
<li>当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li>
<li>当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li>
<li>当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作</li>
</ul>
<p><strong>undo log</strong>记录了这些回滚需要的信息，当事务执行失败或调用了<strong>rollback</strong>，导致事务需要回滚，便可以利用<strong>undo log</strong>中的信息将数据回滚到修改之前的样子。</p>
<h2 id="数据库如何保证持久性？"><a href="#数据库如何保证持久性？" class="headerlink" title="数据库如何保证持久性？"></a>数据库如何保证持久性？</h2><p>主要是利用Innodb的<strong>redo log</strong>。重写日志， 正如之前说的，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再写回到磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？ 简单啊，事务提交前直接把数据写入磁盘就行啊。 这么做有什么问题？</p>
<ul>
<li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</li>
<li>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li>
</ul>
<p>于是，决定采用<strong>redo log</strong>解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在<strong>redo log</strong>中记录这次操作。当事务提交的时候，会将<strong>redo log</strong>日志进行刷盘(<strong>redo log</strong>一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据<strong>undo log</strong>和<strong>binlog</strong>内容决定回滚数据还是提交数据。</p>
<p><strong>采用redo log的好处？</strong></p>
<p>其实好处就是将<strong>redo log</strong>进行刷盘比对数据页刷盘效率高，具体表现如下：</p>
<ul>
<li><strong>redo log</strong>体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li>
<li><strong>redo log</strong>是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li>
</ul>
<h2 id="说一下数据库表锁和行锁吧"><a href="#说一下数据库表锁和行锁吧" class="headerlink" title="说一下数据库表锁和行锁吧"></a>说一下数据库表锁和行锁吧</h2><p><strong>表锁</strong></p>
<p>表锁是一种粗粒度的锁，它锁定整个数据表，即当一个事务获取了表锁后，其他事务无法对整个表进行写操作。不会出现死锁，发生锁冲突几率高，并发低。</p>
<p>MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。MyISAM只支持表锁。</p>
<p>MySQL的表级锁有两种模式：表共享读锁和表独占写锁。</p>
<p><strong>行锁</strong></p>
<p>行锁是一种细粒度的锁，它只锁定数据表中的某一行，允许其他事务对其他行进行操作。会出现死锁，发生锁冲突几率低，并发高。</p>
<p>在 MySQL 数据库中，InnoDB 存储引擎是默认的事务型存储引擎，它支持行级锁。</p>
<h2 id="对于MySQL来说，select使用的是行锁还是表锁？"><a href="#对于MySQL来说，select使用的是行锁还是表锁？" class="headerlink" title="对于MySQL来说，select使用的是行锁还是表锁？"></a>对于MySQL来说，select使用的是行锁还是表锁？</h2><p>锁表跟存储引擎 InnoDB和MyISAM关系很大，而MySQL 的 InnoDB 存储引擎是默认的事务型存储引擎，并且它还支持行级锁。</p>
<p>对于MyISAM的表select 是会锁定表的 ，会导致其他操作挂起，处于等待状态。<br>对于InnoDB的表select 有些情况是表锁，有些情况是行锁。</p>
<ul>
<li>明确指定主键则是行锁，无主键或主键不明确是表锁。 也可以理解成有索引的查询语句在InnoDB引擎下是行锁，没有索引的话是表锁</li>
</ul>
<h2 id="QL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？"><a href="#QL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？" class="headerlink" title="QL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？"></a>QL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？</h2><p>内连接：只有两个元素表相匹配的才能在结果集中显示。 外连接： 左外连接: 左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 右外连接:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。 全外连接：连接的表中不匹配的数据全部会显示出来。 交叉连接： 笛卡尔效应，显示的结果是链接表数的乘积。</p>
<h2 id="你知道哪些数据库结构优化的手段？"><a href="#你知道哪些数据库结构优化的手段？" class="headerlink" title="你知道哪些数据库结构优化的手段？"></a>你知道哪些数据库结构优化的手段？</h2><ul>
<li><strong>表的设计</strong>：<ul>
<li>使用适当的数据类型：选择合适的数据类型，避免过大的存储空间和不必要的计算开销。</li>
<li>规范化和反规范化：根据业务需求进行表的规范化和反规范化，平衡数据冗余和查询性能。</li>
<li>垂直拆分和水平拆分：根据数据特点和查询模式，将大的表拆分为多个子表，提高查询效率和维护性。</li>
</ul>
</li>
<li><strong>索引的优化</strong>：<ul>
<li>使用合适的索引：为经常用于查询和连接的字段创建索引，避免过度索引。</li>
<li>考虑多列索引：根据多列的查询需求，创建复合索引以提高多列查询的性能。</li>
<li>避免过长的索引：过长的索引会导致额外的磁盘消耗和降低性能。</li>
</ul>
</li>
<li><strong>查询的优化</strong>：<ul>
<li>编写高效的查询语句：避免使用<code>SELECT *</code>，只选择需要的字段，优化JOIN操作等。</li>
<li>避免子查询和OR操作：尽量避免复杂的子查询和OR操作，可以使用JOIN和UNION等替代。</li>
</ul>
</li>
<li><strong>缓存的利用</strong>：<ul>
<li>使用查询缓存：但注意只适用于不经常变化的数据，因为更新会导致缓存失效。</li>
<li>内存缓存：使用内存数据库或内存表，加速读取操作，减少磁盘访问。</li>
</ul>
</li>
<li><strong>分区技术</strong>：<ul>
<li>分区表：根据特定的列将表分成多个分区，提高查询效率和维护性。</li>
<li>分区索引：在分区表上创建合适的索引，提高查询性能。</li>
</ul>
</li>
<li><strong>物化视图</strong>：<ul>
<li>物化视图是预计算和存储的查询结果，提高复杂查询的性能。</li>
<li>定期刷新：根据数据更新频率定期刷新物化视图。</li>
</ul>
</li>
<li><strong>表分片</strong>：<ul>
<li>将表的数据水平分散到不同的数据库实例中，提高查询性能和可扩展性。</li>
<li>分片键：选择合适的分片键，确保数据均匀分布。</li>
</ul>
</li>
<li><strong>并发控制</strong>：<ul>
<li>选择合适的事务隔离级别，平衡一致性和性能。</li>
<li>避免锁冲突，使用合适的锁机制，提高并发性能。</li>
</ul>
</li>
<li><strong>数据归档和清理</strong>：<ul>
<li>对于历史数据，可以进行数据归档或清理，保持数据库的高性能。</li>
</ul>
</li>
</ul>
<h2 id="MySQL优化了解吗？说一下从哪些方面可以做到性能优化？"><a href="#MySQL优化了解吗？说一下从哪些方面可以做到性能优化？" class="headerlink" title="MySQL优化了解吗？说一下从哪些方面可以做到性能优化？"></a>MySQL优化了解吗？说一下从哪些方面可以做到性能优化？</h2><ul>
<li><strong>查询优化</strong>：<ul>
<li>使用合适的索引：为经常查询的字段创建合适的索引，以加快查询速度。</li>
<li>避免全表扫描：尽量避免使用<code>SELECT *</code>语句，只选择需要的字段，减少不必要的数据传输。</li>
<li>使用JOIN时注意性能：优化JOIN查询，确保连接条件和索引的使用效率。</li>
</ul>
</li>
<li><strong>索引优化</strong>：<ul>
<li>确保适当的索引：为经常用于查询和连接的字段创建索引，但不要过度索引，以避免降低写入性能。</li>
<li>避免过长的索引：过长的索引会导致额外的磁盘空间消耗和降低性能。</li>
</ul>
</li>
<li><strong>表设计优化</strong>：<ul>
<li>使用适当的数据类型：选择合适的数据类型可以减少存储空间并提高查询性能。</li>
<li>避免过大的表：分拆过大的表，进行垂直拆分或水平拆分，以提高查询效率。</li>
</ul>
</li>
<li><strong>缓存优化</strong>：<ul>
<li>使用查询缓存：但注意只有适用于少量不经常变化的数据，因为大量更新会导致缓存失效。</li>
<li>使用内存缓存：利用内存数据库或内存表，加速读取操作。</li>
</ul>
</li>
<li><strong>配置优化</strong>：<ul>
<li>调整MySQL配置参数：根据系统硬件、负载和需求调整MySQL的配置参数，以达到最佳性能。</li>
<li>合理分配内存：合理配置缓冲区大小，确保常用表的数据在内存中。</li>
</ul>
</li>
<li><strong>并发优化</strong>：<ul>
<li>使用合理的事务隔离级别：根据应用需求选择合适的事务隔离级别，平衡一致性和性能。</li>
<li>避免锁冲突：使用合适的锁机制，避免长时间的锁等待。</li>
</ul>
</li>
<li><strong>硬件优化</strong>：<ul>
<li>使用SSD存储：使用固态硬盘(SSD)可以大幅提高I&#x2F;O性能。</li>
<li>使用足够的内存：确保有足够的内存以缓存热点数据，减少磁盘访问。</li>
</ul>
</li>
<li><strong>监控和调优</strong>：<ul>
<li>定期监控数据库性能：使用监控工具跟踪数据库的性能指标，及时发现瓶颈。</li>
<li>针对瓶颈进行调优：根据监控结果进行针对性的调优，解决性能问题。</li>
</ul>
</li>
</ul>
<h2 id="SQL中的NOW-和CURRENT-DATE-两个函数有什么区别？"><a href="#SQL中的NOW-和CURRENT-DATE-两个函数有什么区别？" class="headerlink" title="SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？"></a>SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？</h2><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。</p>
<p> CURRENT_DATE（）仅显示当前年份，月份和日期。</p>
<h2 id="MySQL中CHAR和VARCHAR的区别有哪些？"><a href="#MySQL中CHAR和VARCHAR的区别有哪些？" class="headerlink" title="MySQL中CHAR和VARCHAR的区别有哪些？"></a>MySQL中CHAR和VARCHAR的区别有哪些？</h2><ul>
<li>char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的，varchar比char更节省空间。</li>
<li>char的存取速度还是要比varchar要快得多</li>
<li>varchar在更新长度时（比原来长度更长），有可能导致分裂页。导致出现碎片问题。根据存储结构的特性，也导致了更新数据时，char的性能比varchar要更好。</li>
</ul>
<p>适合varchar的场景：</p>
<ol>
<li><p>字符串的最大长度比平均长度大很多；</p>
</li>
<li><p>列的更新很少，所以碎片不是问题。</p>
</li>
</ol>
<p>适合char的场景:</p>
<ol>
<li><p>存储很短的字符串或者所有值都接近同一个长度，例如md5、ip等信息。</p>
</li>
<li><p>经常变更的数据。（如果是要varchar就容易产生碎片）</p>
</li>
</ol>
<h2 id="数据库高并发是我们经常会遇到的，你有什么好的解决方案吗？"><a href="#数据库高并发是我们经常会遇到的，你有什么好的解决方案吗？" class="headerlink" title="数据库高并发是我们经常会遇到的，你有什么好的解决方案吗？"></a>数据库高并发是我们经常会遇到的，你有什么好的解决方案吗？</h2><ul>
<li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li>增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读。</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li>
<li>使用分布式架构，分散计算压力。</li>
</ul>
<h2 id="一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？"><a href="#一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？" class="headerlink" title="一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？"></a>一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？</h2><ul>
<li>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</li>
<li>选择合适的表字段数据类型和存储引擎，适当的添加索引。</li>
<li>MySQL库主从读写分离。</li>
<li>找规律分表，减少单表中的数据量提高查询速度。</li>
<li>添加缓存机制，比如Memcached，Apc等。</li>
<li>不经常改动的页面，生成静态页面。</li>
<li>书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag"># 八股文</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A1%E6%96%87/" rel="prev" title="操作系统八股文">
                  <i class="fa fa-chevron-left"></i> 操作系统八股文
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/04/18/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" rel="next" title="LeetCode刷题记录">
                  LeetCode刷题记录 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
